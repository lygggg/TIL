## 이장의 내용
- 명령형 에러 처리 체계의 문제점
- 컨테이너로 잘못된 데이터 접근을 차단
- 함수자를 자료 변환 도구로 활용
- 모나드는 합성을 촉진하는 자료형
- 에러 처리 전략을 모나드형에 통합
- 모나드형의 교차 배치 및 합성

> Null 참조는 10억 달러짜리 실수다.
> - 찰스 앤터니 호어, 2009년 QCon 발표에서

함수형 프로그래밍은 다른 프로그래밍보다 에러를 더 깔끔하게 잘 처리한다.

### 5.1 명령형 에러 처리의 문제점
- 명령형 코드는 대부분 try-catch 구문으로 예외를 처리한다.
- 루프와 조건문을 함수로 추상했던 것처럼 에러 처리도 어떤 식으로든 추상화할 필요가 있다. 함수에 try-catch를 쓰면 다른 함수와 합성/체이닝을 할수도 없고 코드 설계시 적잖은 압박을 받기 떄문이다.

### 5.1.2 함수형 프로그램은 왜 예외를 던지지 않을까?
기본적으로 예외를 덜지는 함수의 특징은 다음과 같습니다.
- 다른 함수형 장치처럼 합성이나 체이닝을 할 수 없습니다.
- 예외를 던지는 행위는 함수 호출에서 빠져나갈 구멍을 찾는 것이므로 단일한, 예측 가능한 값을 지향하는 참조 투명성 원리에 위배됩니다.
- 예기치 않게 스택이 풀리면 함수 호출 범위를 벗어나 전체 시스템에 영향을 미치는 부수 효과를 일으킵니다.
- 에러를 조치하는 코드가 당초 함수를 호출한 지점과 동떨어져 있어서 비지역성 원리에 위배됩니다. 에러가 나면 함수는 지역 스택과 환경에서 벗어납니다.
- 함수의 단일 반환값에 신경 써야 할 에너지를, catch 블록을 선언해 특정 예외를 붙잡아 처리하는 데에 낭비하면서 호출자의 부담이 가중됩니다.
- 다양한 에러 조건을 처리하는 블록들이 중첩되어 사용하기 어렵습니다.

### 5.1.3 null 체크라는 고질병
뜻밖의 함수 호출이 실패하는 것보다, 차라리 null을 돌려받으면 적어도 함수를 한군데로 흘러가게 할 수는 있다. 하지만 함수가 null을 반환하면 이 함수를 부른 호출자는 성가신 null 체크를 해야하는 부담을 떠안는다.

### 5.2 더 나은 방안: 함수자
잠재적으로 위험한 코드 주위에 안전망을 설치하는 것이다. 함수형 프로그래밍에서는 위험한 코드를 감싼다는 개념은 그대로 가져가되, try-catch 블록은 제거할 수 있다. 함수형 자료형을 사용하여 불순함과의 분리를 일급 시킨으로 만드는 것이다. 

### 5.2.1
값을 컨테이너화 하는 행위는 함수형 프로그래밍의 기본 디자인 패턴이다. 값을 안전하게 다루고 프로그램의 불변성이 지켜지도록 직접적인 접근을 차단하는 것이다. 이렇게 감싼 값에 접근하는 유일한 방법은 연산을 컨테이너에 매핑하는 것이다.

맵을 배열에 적용할 때에는 배열이 바로 값(원소)를 감싼 컨테이너에 해당된다. 굳이 배열이 아니더라도 함수를 매핑할 대상은 무궁무진하다. 함수형 자바스크립트에서 맵은 함수 그이상, 이하도 아니다.

함수는 반드시 동일 입력을 동일 결과에 매핑해야 한다.

```tsx
class Wrapper {
	constructor(value) {
	this._value = value;
	}

	// map :: (A->B)->A->B)
	map(f) {
		return f(this._value)
		};
		
	toString() {
		return "Wrapper (" + this._value + ")"
	}
}

// wrap :: A -> Wrapper(A)
const wrap = (val) => new Wrapper(val);
```

요점은 에러가 날지 모를 값을 래퍼 객체로 감싼다는 것이다. 값에 직접 접근할 순 없으니 값을 얻으려면 4장에서 배운 identity 함수를 써야한다. 자바스크립트 코드로 이값에 접근하는 건 얼마든지 가능하지만, 일단 어떤 값이 컨테이너 속으로 들어가면 절대로 값을 직접 조회/변경할 수 없다.

```tsx
const wrappedValue = wrap("Get Functional");
wrappedValue.map(R.identity); // 'Get Functional'
```

콘솔에 로그를 남기거나 값을 조작하는 함수를 컨테이너에 매핑하는 것도 가능하다.
```tsx
wrappedValue.map(console.log);
wrappedValue.map(R.toUpper);
```
이 단순한 아이디어 덕분에, 컨테이너 안에 넣어 보호된 값을 얻고 싶은 코드는 무조건 Wrapper.map을 통해서만 "컨테이너 내부에 손을 뻗칠 수 있는" 구조로 만들 수 있다.

보호된 값을 얻으려면 반드시 어떤 함수를 이 콘텍스트에 적용할 수 밖에 없다. 직접 함수를 호출하진 못한다. 그래서 설사 에러가 나더라도 그 뒷일은 구체화한 래퍼 형식에 넘길 수 있다. 즉 함수를 호출하기 전에 null, 빈 문자열, 음수 등을 체크할 수 있다. 결국 Wrapper.map의 의미는 래퍼 형식을 실제로 어떻게 구현하는가에 따라 결정된다.

다음은 map을 변형한 fmap 함수다.

```tsx
// fmap :: (A->B) -> Wrapper[A] -> Wrapper[B]
fmap (f) {
return new Wrapper(f(this._value));
}
```
먼저 컨테이너를 열고 그 안에 보관된 값에 주어진 함수를 적용한 다음, 그 결과를 동일한 형식의 새 컨테이너에 넣고 닫는 것으로 마무리하는 함수를 `함수자` 라고한다.

### 함수자의 세계로
`함수자`는 값을 래퍼 안으로 승급한 다음 수정하고 다시 래퍼에 넣을 목적을 염두에 둔 함수 매핑이 가능한 자료구조입니다. fmap이 어떻게 움직여야 하는지는 디자인 패턴에 따라 달라진다.

```tsx
fmap :: (A->B) -> Wrapper(A) -> Wrapper(B)
```
fmap 함수는 함수(A->B)와 함수자(감싼 콘텍스트) Wrapper(A)를 받아 새로운 함수자 Wrapper(B)를 반환한다. 이렇게 반환된 함수자에는 주어진 함수를 값에 적용한 후 다시 래퍼로 감싼 결과가 담겨있다.

```tsx
const plus = R.curry((a,b) => a+b);
const plus3 = plus(3);

const two = wrap(2);

const five = two.fmap(plus3); // -> Wrapper(5)
five.map(R.identity); // -> 5
```

함수자는 몇가지 중요한 전제 조건이 존재한다.
- 부수효과가 없어야 한다.
- 합성이 가능해야 한다.

함수자로는 예외를 던지거나, 원소를 바꾸거나, 함수 로직을 변경하는 일 따위는 할 수 없다. 콘텍스트를 생성 또는 추상하여 원본 값을 바꾸지 않은 상태로 안전하게 꺼내어 연산을 수행하는 것이 함수자의 존재 이유이다.

함수자는 null 데이터를 다루는 법을 알지 못하므로 그 자체로는 별로 매력이 없다. 쉬운 예를 들어 R.compose로 합성 시 함수 레퍼런스를 null로 전달하면 바로 사달이 난다. 하지만 이것은 설계상의 결함이 아니라 일부로 그렇게 만든 것이다. `함수자는 한 형식의 함수를 다른 형식의 함수로 매핑합니다.`

모나드는 그 무엇보다 능률적으로 코드 에러를 처리해서 물 흐르듯 매끄럽게 함수 합성을 가능케 한다. 함수자가 건드리는 컨테이너가 바로 모나드다.

모나드의 주 목적은 어떤 자원(단순 값, DOM요소, 이벤트, AJAX)을 추상하여 그 속에  든 데이터를 안전하게 처리하는 것. 이런 점에서 제이쿼리 역시 일종의 DOM 모나드인 셈이다.

### 5.3 모나드를 응용한 함수형 에러 처리
모나드를 함수형 프로그래밍에 응용하면 앞서 언급한 전통적인 에러 처리의 문제점을 일거에 해소할 수 있다.

```tsx
const findStudent = R.curry((db, ssn) => wrap(find(db,ssn))) // 객체를 발견하지 못할 경우를 대비하여 조회한 객체를 감쌉니다.
const getAddress = student => wrap(student.fmap(R.prop('address'))) // R.prop()함수를 객체에 매핑하여 주소를 얻고 그 결과를 다시 감쌉니다.

studentAddress('444-44-4444') // -> Wrapper(Wrapper(address))
```

두 함수를 합성하여 호출하면
```tsx
const studuentAddress = R.compose(getAddress, findStudent(DB('student')))
```

에러 처리 코드는 자취를 감췄지만, 실행 결과는 예상과 다르다. 실제로 감싼 주소 객체가 아닌, 이중으로 감싼 주소 객체가 반환된다.
```tsx
studentAddress('444-44-4444') // -> Wrapper(Wrapper(address))
```

그러니 값을 얻으려면 R.identity도 두 번 적용해야한다.

```tsx
studentAddress('444-44-4444').map(R.identity).map(R.identity);
```

이런 방법은 너무 비효율적이다. 그래서 우린 다른 방법을 찾아야 하는데 그게 바로 모나드다.

### 5.3.1 모나드: 제어 흐름에서 데이터 흐름으로
특정한 케이스를 특정한 로직에 위임하여 처리할 수 있다는 점을 제외하면 모나드는 함수자와 비슷하다.

- 모나드: 모나드 연산을 추상한 인터페이스를 제공한다.
- 모나드형: 모나드 인터페이스를 실제로 구현한 형식이다.
- 형식 생성자: 모나드형을 생성한다.
- 단위 함수: 어떤 형식의 값을 모나드에 삽입한다. 방금전 wrap,empty 함수와 비슷하나, 모나드에서는 of라고 함수를 명명한다.
- 바인드 함수: 연산을 서로 체이닝 한다.(함수자의 fmap에 해당하며, flatMap이라고도 한다.)
- 조인 연산: 모나드 자료구조의 계층을 눌러 편다. 모나드 반환 함수를 다중 합성할 떄 특히 중요하다.

### 5.3.2 Maybe와 Either 모나드로 에러 처리
모나드는 유효한 값을 감싸기도 하지만 값이 없는 상태, 즉 null이나 undefined를 모형화 할 수 있다.함수형 프로그래밍에서는 Maybe/Either형으로 에러를 구상화하여 이런 일들을 처리한다.
- 불순 코드를 격리
- null 체크 로직을 정리
- 예외를 던지지 않음
- 함수 합성을 지원
- 기본값 제공 로직을 한곳에 모음

마치며
- 객체지향 방식으로 예외를 처리하면 결국 호출자가 try-catch 로직으로 예외를 붙잡아 처리해야 하므로 담당해야 할 일이 많습니다.
- 하나의 참조 투명한 프로세스에서 가능한 변이를 모두 감싸는 패턴을, 즉 값을 컨테이너화 하는 패턴을 따르면 부수효과 없이 코드를 작성할 수 있습니다.
- 부수효과 없이, 불변적으로 객체를 접근/변경하려면 함수자를 써서 함수를 컨테이너에 매핑합니다.
- 모나드는 함수형 프로그래밍의 디자인 패턴으로, 함수 간에 데이터가 안전하게 흘러가도록 조정하여 애플리케이션의 복잡도를 낮추는 역할을 합니다.
- Maybe, Either, IO 등의 모나드형을 교차 배치하면 탄력적으로, 빈틈없이 함수를 합성할 수 있습니다.