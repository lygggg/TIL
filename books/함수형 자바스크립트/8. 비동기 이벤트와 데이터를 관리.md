 ## 이 장의 내용
 - 비동기 코드 개발의 어려움
 - 함수형 기법으로 중첩된 콜백 사용을 막음
 - 프로미스를 응용하여 비동기 코드를 능률화
 - 함수 제네레이터로 데이터를 느긋하게 만듦
 - 리액티브 프로그래밍 입문
 - 리액티브 프로그래밍을 적용한 이벤트 중심 코드

> 함수형 프로그래머는 함수형 프로그래밍이 엄청나게 유익하다고 주장합니다. 기존 프로그램보다 한 자릿수나 더 짧은 함수형 프로그램이 생산성은 외려 한 자릿수 더 생산적이라고 하지요 -존 휴스-

구형 웹 미들웨어와 통신, 사용자 입력의 효율적인 처리, 원격 서버 통신, 데이터 화면 표시 등 여러 가지 일을 한꺼번에 처리하는 부담이 가중됐다. 그래서 필자는 무결성을 지켜야 하는 시스템의 이상적인 해결책으로 함수형 프로그래밍을 권장한다.

### 8.1 골칫덩이 비동기 코드
- 요즘 자바스크립트 프로그램은 단일 요청으로 로드되는 경우가 거의 없다. 보통의 자바스크립트 개발자는 대부분 비차단 비동기 호출 코드를 구현한다. 하지만 다음과 같은 문제가 존재한다.
	- 함수 간에 일시적 의존 관계가 형성
	- 어쩔 수 없이 콜백 피라미드의 늪에 빠짐
	- 동기/비동기 코드의 호환되지 않는 조합

### 8.1.1 함수 간에 일시적 의존 관계가 형성
- `일시적 결합`은 어떤 함수를 논리적으로 묶어 실행할 때 발생한다. 데이터가 도착할 때까지, 또는 다른 함수가 실행될 때까지 어떤 함수가 기다려야하는 경우다. 데이터든 시간이든 어느 쪽에 의지하는 순간부터 부수효과가 발생한다.
- 원격 IO 작업은 나머지 다른 코드에 비해 속도가 느릴수 밖에 없으므로 데이터 요청 후 다시 돌아올 때 까지 "대기" 가능한 비차단 프로세스에게 처리를 위임한다. 개발자가 작성한 콜백 함수는 데이터를 받는 시점에 호출된다.

### 8.1.2 콜백 피라미드의 늪에 빠짐
- 콜백의 주용도는 처리 시간이 오래 걸리는 프로세스를 기다리는 도중 UI를 차단하지 않는 것이다. 콜백을 받는 함수는 값을 반환하는 대신 `제어의 역전`을 몸소 실천하여 "날 부르지 말게, 내가 자넬 부를  테니"라고 말하는 셈이다. 데이터 수신 또는 사용자 버튼 클릭 등의 이벤트가 발생하면 즉시 요청한 데이터를 콜백 함수에 넣고 호출해서 동기 코드를 실행한다.

### 8.2 비동기 로직을 프로미스로 일급화
-   합성과 무인수 프로그래밍을 이용
-   중첩된 구조를 보다 선형적으로 눌러 폄
-   일시적 결합은 추상하기 때문에 개발자는 신경쓰지 않음
-   여러 콜백 대신, 단일 함수로 에러 처리 로직을 통합

위의 특성들은 모나드가 할 일과 같으며, **프로미스** 또한 모나드다. (오래 걸리는 계산을 모나드로 감싸는 개념) 다만 이전의 모나드와 달리 프로미스는 오래 걸리는 계산이 끝날 때까지 기다렸다가 미리 매핑한 함수를 실행한다. 비동기 호출에서의 문제를 프로미스라는 자료구조로 해결하는 것이며, 복잡한 계산이나 DB/서버로부터 데이터 조회 또는 파일 IO 작업등의 값이나 함수를 프로미스로 감싸는 것이다.

프로미스의 상태는 언제나 **보류**(pending), **이룸**(fulfilled), **버림**(rejected), **귀결**(settled) 중 하나다. 처음은 보류 상태로 시작해 오리 걸리는 작업 결과에 따라 이룸 또는 버림상태로 분기하고, 프로미스가 문제없이 이루어지면 귀결된 상태라 봅니다. null 체크하는 if-else 중첩문을 Maybe 모나드로 제거했던 것처럼 프로미스를 통해 중첩된 콜백 함수를 일련의 작업들로 전환할 수 있다.

### 8.2.1 미래의 메서드 체인
프로미스 객체는 then 메서드를 지닙니다. Maybe.map(f) 처럼 Promise.then(f) 는 데이터 변환 작업을 서로 체이닝하고 여러 함수를 제때 모아 함수 사이의 일시적인 결합을 추상하는 용도로 쓰인다.

API 를 프로미스화 하면 기존 콜백보다 훨씬 코드를 다루기 쉬워 여러모로 좋습니다. 데이터 조회뿐 아니라 오래 걸리는 어떤 종류의 작업도 프로미스로 감쌀 수 있기 때문에 then 메서드를 구현한 객체 (**데너블**) 와 병용할 수 있다.

프로미스는 비동기 흐름을 숨기지만 시간 관념은 then 으로 분명히 드러내기 때문에 프로미스화 한 함수를 다른 프로미스 함수로 쉽게 변경 가능하고 그럼에도 동작은 똑같습니다. 이런 수준의 유연성을 **위치 투명성** 이라고 한다.

프로미스는 또한 브라우저의 다중 접속 기능을 활용하여 한 번에 여러 데이터 항목 조회도 가능한데, 데이터를 조회하는 순서나 어느 요청이 더 빨라야 하는지를 고려할 필요가 없이 동시에 작업을 진행하는 경우 Promise.all() 을 사용하면 됩니다.

### 8.3 느긋한 데이터 생성
ES6 의 가장 강력한 특성 중 하나는 어떤 함수를 끝까지 실행하지 않아도 데이터 제공을 잠시 중단한 상태로 다른 함수들과 더불어 작동시키는 능력이다. **제너레이터** 함수는 function* 라고 표기하는, 언어 수준에서 지원되는 장치입니다. 이 함수는 새로운 키워드인 yield 를 만나면 잠시 밖으로 나갔다가 자신의 보관된 컨텍스트를 찾아 다시 돌아오는 동작을 한다.

### 8.3.1 제너레이터와 재귀
일반 함수 호출과 마찬가지로 제너레이터도 다른 제너레이터를 호출할 수 있습니다. 제너레이터는 for..of 루프문으로 반복할 수 있기 때문에 다른 제너레이터에게 위임하는 건 두 컬렉션을 병합한 전체 컬렉션을 반복하는 것과 비슷하다.

### 8.3.2 이터레이터 프로토콜
제너레이터는 또 다른 ES6 기능인 **이터레이터**와 밀접한 관계가 있다. 제너레이터 함수는 내부적으로 이터레이터 프로토콜에 따라 yield 키워드로 값을 반환하는 next() 메서드가 구현된 Generator 객체를 반환한다. 아래는 Generator 객체의 속성이다.

-   done : 제일 마지막에 이터레이터가 전달되면 ture, 그외에는 false (false 는 이터레이터가 아직 다른 값을 생산할 수 있음을 의미)
-   value : 이터레이터가 반환한 값

- 프로미스는 콜백 중심적인 설계를 함수형으로 해결하는 방안
- 미래의 함수를 프로미스로 합성, 체이닝하면 일시적으로 의존 관계가 형성된 코드의 잡다한 저수준 로직 추상화 가능
- 제너레이터는 비동기 코드에 접근하는 또 다른 방안으로, 느긋한 이터레이터로 데이터를 쓸 수 있는 시점에 내어주는 장치
- 함수형 리액티브 프로그래밍은 프로그램의 추상화 수준을 높여 이벤트를 논리적 독립된 단위로 다룰 수 있게 함