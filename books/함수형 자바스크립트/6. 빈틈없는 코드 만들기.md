## 이 장의 내용
- 함수형 프로그래밍과 프로그램 테스트
- 명령형 코드 테스트의 어려움
- QUnit으로 함수형 코드를 테스트
- JSCheck를 응용한 속성 기반 테스트
- 블랭킷JS로 프로그램 복잡도를 측정

```tsx
담장이 튼튼해야 이웃 사이가 좋지요
- 로버트 프로스트 [담장 고치기] 중에서
```

### 6.1 함수형 프로그래밍과 단위 테스트
- 인수 테스트
	- 인수 테스트는 소프트웨어 패러다임과 무관함
- 통합 테스트
	- FP는 코드에 존재하는 여러 모듈을 합리적으로 통합할 수 있음
- 단위 테스트
	- FP는 코드베이스 하위 계층에 영향을 미침
코드에 미치는 FP의 영향력은 인수 테스트에서 단위 테스트쪽으로 갈수록 확대된다. 왜냐하면 함수형 프로그래밍은 함수와 모듈의 설계, 그리고 그 구성 요소의 통합에 집중하는 소프트웨어 개발 패러다임이기 때문이다.

### 6.2 명령형 프로그램 테스트의 어려움
명령형 테스트는 명령형 코드만큼이나 쉽지 않다. 명령형 코드는 데이터 흐름을 보관하고 계산을 조합하는 대신, 전역 상태와 변이에 의존하기 때문에 테스트하기가 정말 어렵다. 단위 테스트 설계의 주요 원칙 중 하나가 격리다. 단위 테스트는 진공 상태에 떠 있는 것 처럼 다른 데이터나 주변 테스트에 상관없이 실행돼야 하지만, 부수효과를 유발하는 코드는 기능을 테스트할 때 심한 제약을 받게 된다.

#### 명령형 코드의 문제점
1. 식별은 물론 간단한 작업으로 분해가 어렵다.
2. 결과를 들쭉날쭉하게 만드는 공유 자원에 의존해야한다.
3. 반드시 평가 순서를 미리 정해야 한다

단위 테스트는 일관성 차원에서 `결함적`이어야 한다. 즉 실행 순서를 바꿔도 결과가 달려져선 안된다. 이미 앞서 설명한 이유 때문에 불순한 함수는 이 원칙이 통하지 않는다. 그래서 QUit 같은 단위 테스트 라이브러리는 후속 테스트를 실행할 전역 테스트 환경을 구성 정리하는 편리한 도구를 제공함으로써 이 문제를 해결합니다. 하지만 우리가 각 테스트 대상의 코드 부수효과들을 모두 찾아내야하는 문제점이 존재한다.

함수형 사고방식은 테스트 스위트를 안정적으로 구축하는데 도움이 된다. 사실 함수형으로 코딩만 해도 저절로 그렇게 된다. 애초에 처음부터 시간들 들여서 함수형으로 코딩한 다음, 투자한 시간을 테스트 단계에서 뽑아내도록 하자.

### 6.3 함수형 코드를 테스트
명령형이든 함수형이든, 격리, 예측성, 반복성 등 단위 테스트를 개발하는 최상의 지침은 대부분 매한가지다. FP의 모든 함수는 입력 매개변수가 명확히 정의되어 있으므로 여러 가지 경계 조건 집합을 제공하여 코드를 구석구석 살피는 일은 어렵지 않다. 부수효과 측면에서도 모든 함수는 단순 명료하게 정의되며, 불순한 코드는 모나드로 안전하게 감쌀 수 있다고 했다. 또 수동 루프의 고질적인 불순함도 map, reduce, filter, 재귀 등의 고계 연산과 부수효과 없는 함수형 라이브러리에 위임하여 해결함으로써  코드의 복잡성을 추상하여 좀 더 생산적으로, 주요 비즈니스 로직만 신경쓰면서 테스트를 진행할 수 있다.

#### 함수형 코드를 테스트하면 생기는 장점
- 함수를 블랙박스처럼 취급
	- 함수형 프로그래밍에서는 애플리케이션의 다른 부분에 구애받지 않고 느슨하게 입력값을 결합하는 함수를 독립적으로 작성합니다. 이런 함수는 부수효과가 없고 참조 투명하므로, 임의의 순서로 몇 번이고 실행하더라도 결과가 동일하고 예측 가능한 테스트를 작성할 수 있습니다.
- 제어 흐름 대신 비즈니스 로직에 집중

```tsx
const fork = (join, func1, func2) =>
	(val) => {
		join(func1(val), func2(val));
	};

const toLetterGrade = (grade) => {
	if(grade >= 90) return "A";
	if(grade >= 80) return "B";
	if(grade >= 70) return "C";
	if(grade >= 60) return "D";
}

const computeAverageGrade =
	  R.compose(toLetterGrade, fork (R.divide, R.sum, R.length));

QUnit.test("평균 학점을 계산", function(assert) {
	assert.equal(computeAverageGrade([80,90,100]), "A");
})
```

이 프로그램은 R.divide, R.sum, R.length 같은 단순 함수를 커스텀 함수 조합기 fork로 조합한 후, 그 결과를 toLetterGrade와 합성합니다. 람다JS의 함수들은 이미 완벽히 검증 거친 것이므로 굳이 다시 테스트할 필요는 없습니다.

toLetterGrade 단위 테스트를 작성해보자.
```tsx
QUnit.test('평균 학점을 계산: toLetterGrade', function (assert) {
assert.equal(toLetterGrade(90), 'A');
assert.equal(toLetterGrade(200), 'A');
assert.equal(toLetterGrade(80), 'B');
assert.equal(toLetterGrade(89), 'B');
assert.equal(toLetterGrade(70), 'C');
assert.equal(toLetterGrade(60), 'D');
assert.equal(toLetterGrade(59), 'F');
assert.equal(toLetterGrade(-10), 'F');
})
```
toLetterGrade는 순수 함수이기 떄문에 입력값과 경계 조건을 몇 번이고 바꿔가며 테스트해도 상관없고, 참조 투명한 함수라 테스트 케이스 순서를 바꿔도 결과는 같습니다.

마지막으로 fork 함수는 제어 흐름에 맞게 함수를 호출하는 기능 외에는 다른 비즈니스 로직은 전혀 없으므로 테스트할 필요가 없습니다.
- 모나드 격리를 통해 순수한 부분과 불순한 부분을 분리
- 외부 디펜던시를 모의
	- `모의` 모킹은 함수의 외부 디펜던시를 제어/단언 가능한 방향으로 모방하는 데 많이 쓰입니다. 부수효과를 다루기 좋은 테스트 기법입니다.
	- 모의 객체는 기대식을 충족하지 않을 경우 테스트를 불합격 처리하며, 프로그램 가능한 깡통 메서드와 같아서 여러분이 작성한 함수와 상포작용하는 객체가 해야할 일을 미리 여기에 정의합니다.

### 결론
- 아주 단순한 함수들을 결합하는 추상화로 프로그램을 모듈화 할 수 있습니다.
- 순수함수에 기바늘 둔 모듈적인 코드는 테스트하기 쉽고, 속성 기반 테스트처럼 더 엄격한 테스트 방법론을 적용할 수 있습니다.
- 테스트 가능한 코드가 되려면 제어 흐름이 직관적이어야 합니다.
- 제어 흐름을 단순화하면 전체 프로그램의 복잡도가 줄어듭니다. 복잡도는 각종 지표를 통해 정량적으로 측정할 수 있습니다.
- 복잡도가 줄면 프로그램을 읽고 이해하기 쉽습니다.