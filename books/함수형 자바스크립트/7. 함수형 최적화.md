 ## 이 장의 내용
 - 함수형 코드가 성능 기준을 만족하는지 판별
 - 자바스크립트 함수 실행의 내부 원리
 - 함수 콘텍스트와 재귀 중첩의 함의
 - 느긋한 평가로 함수 계산을 최적화
 - 메모화로 프로그램을 빠르게 함
 - 꼬리 재귀 함수로 재귀 호출을 풂

> 자그마한 효율은 그냥 잊으세요. 대략 97%의 경우 어설픈 최적화가 모든 걸 망쳐놓는 원인이 됩니다. 하지만 나머지 결정적 3%는 최적화할 기회를 절대로 놓쳐서는 안 됩니다. - 도널드 커누스 -

모든 프로그래밍 패러다임이 100% 완벽에 가까울 수는 없다. 성능이냐, 추상화냐 문제도 똑같다. 함수형 프로그래밍은 코드 주위에 추상화 계층을 제공해서 높은 수준의 유창함과 선언성을 실현한다. 이보다 더 단순할까 싶은 문제도 내부적으로 커링, 재귀, 모나드 래핑 등을 조합해 해결하는 과정을 보면서 "그런데, 함수형 코드가 명령형 코드만큼 성능이" 나올까 생각이 들기도 한다.

함수형 프로그래밍은 개별 함수의 평가 속도를 올리기보다는 주로 함수 중복 호출을 피해서 코드가 정말 필요할 때까지 평가를 지연시키는 전략을 구사한다.

### 7.1 함수 실행의 내부 작동 원리
자바스크립트에서는 함수를 호출할 때마다 함수 콘텍스트 스택에 레코드가 생성된다. 콘텍스트 스택은 함수 실행 및 함수가 애워싼 변수를 관리하는 자바스크립트 프로그래밍 모델이다. 스택은 언제나 전역 데이터가 담긴, 전역 실행 콘텍스트 프레임에서 출발한다.

###  스택의 주요 작동 규칙
- 자바스크립트는 단일 스레드로 작동한다. 즉, 동기 실행 방식이다.
- 전역 콘텍스트는 단 하나만 존재한다.(모든 함수 콘텍스트는 전역 콘텍스트를 공유한다.)
- 함수 콘텍스트 개수에 제한은 없다.(클라이언트 측 코드는 브라우저마다 제한 개수가 다르다.)
- 함수를 호출할 때마다 실행 콘텍스트가 새로 생성되며, 자기 자신을 재귀 호출할 때에도 마찬가지다.

함수형 프로그래밍은 함수를 최대한 사용하려고 하므로, 유연성과 재사용을 늘리고자 당면한 문제를 가능한 한 많은 함수로 분해하고 커리하는 건 얼마든지 좋지만, 커리된 함수를 지나치게 사용하면 콘텍스트 스택에 어떤 식으로든 영향을 끼친다.

### 7.1.1 커링과 함수 콘텍스트 스택
- 커링을 사용해 추상화를 한 꺼풀 더 입히면 일반적인 함수 평가보다 콘텍스트에 오버헤드가 더 많이 발생할 수있다.
- 모든 함수를 커리하면 항상 좋을 것 같지만, 과용하면 엄청난 메모리가 소모되면서 프로그램 실행 속도가 현저히 떨어질 수 있다.

### 7.1.2 재귀 코드의 문제점
- 함수가 자신을 호출할 때에도 새 함수 콘텍스트가 만들어진다. 그런데 기저 케이스에 도달할 수 없게 잘못 구현된 재귀 코드를 호출하면 스택 넘침이 일어날 수 있다.
- 특히 원소가 아주 많은 리스트는 map, filter, reduce 등의 고계함수를 이용해서 탐색하는 방법이 좋다. 이런 함수를 쓰면 함수 호출을 중첩하지 않고 반복할 때마다 스택을 계속 재활용할 수 있다.
- 커링과 재귀를 함수에 적용하면 아무래도 명령형 코드보다 메모리를 더 차지하겠지만, 커링을 통한 유연성 및 재사용 측면에서 얻는 이득과 재귀 해법이 선사하는 정확성을 한번 생각해볼 필요가 있다.

### 느긋한 평가로 실행을 늦춤
- 불필요한 함수 호출을 삼가고 꼭 필요한 입력만 넣고 실행하면 여러모로 성능 향상을 기대할 수 있다. 하스켈 같은 함수형 언어는 기본적으로 모든 함수 표현식을 느긋하게 평가하도록 지원한다.
- 자바스크립트는 기본적으로 함수를 조급하게 평가한다. 즉 함수 결과값이 필요한지 따져볼 새도 없이 변수에 바인딩되자마자 표현식 평가를 마친다. 그래서 탐욕스런 평가라고도 한다.

### 7.2.1 대체 함수형 조합으로 계산을 회피
- 느긋한 평가를 제대로 흉내내면 순수 함수형 언어만의 혜택을 누릴 수 있다. 가장 단순한 용레는 함수를 레퍼런스로 전달하고 조건에 따라 한쪽만 호출하여 쓸데없는 계산을 건너뛰는 것이다.
```tsx
const alt = R.curry((func1, func2, val) => fun1(val) || func2(val));
```


### 7.2.2 단축 융합을 활용
- _.chain이라는 로대시js 함수에서, 맨끝에 value() 함수를 사용하면 전체 함수 순차열을 몽땅 실행하도록 만들수있다. 이렇게 하면 프로그램의 서술부와 실행부를 나눌 수 있을 뿐만 아니라, 함수 실행 중 차지하는 공간을 로대시JS가 알아서 효율적으로 통합하여 최적화하도록 지시할 수 있다.
```tsx
_.chain([p1,p2,p3])
.filter(isValid)
.map(_.property('address.country')).reduce(gatherStats, {})
.values()
.sortBy('count')
.reverse()
.reverse()
.first()
.value()
```
- 이처럼 선언적인 형태로 프로그램을 작성하는 건 하고 싶은 일을 미리 정의함으로써 함수가 어떻게 작동하든 신경 쓰지 않고 무슨일을 해야 하는지만 밝힌다는 의미다. 덕분에 `단축 융합`이라는 기법으로 로대시JS가 프로그램 실행을 내부적으로 최적화할 수있다.

### 7.3 `필요할 때 부르리` 전략
- 반복적인 계산을 피하는 것도 애플리케이션 실행 속도를 끌어올리는 방법이다. 객체지향 시스템에서는 함수 호출 전, 캐시나 프록시 계층을 두는 방법을 사용했다.
- 반환 시 유일하게 참조할 수 있는 키를 돌려주고 이 키/값 쌍을 캐시에 보관하는 것이다. `캐시`란 값비싼 연산을 하기 전에 일단 질의하는 중간 저장소/메모리다.

### 7.3.1 메모화
- 메모화 배후의 캐시 전략도 함수 인수로 키값을 만들고 이 키로 계산 결과를 캐시에 보관해두었다가, 이후 다시 같은 인수로 함수를 호출하면 보관된 결과를 즉시 반환한다는 로직은 캐시 전략과 같다.
- 함수의 결과를 해당 입력과 연관시키는 일, 즉 다시 말해, 함수의 입력을 어떤 값으로 계산해내는 건 함수형 프로그래밍 원리인 참조 투명성 덕분에 가능한 것이다.

### 7.3.4 분해하여 메모화를 극대화
- 코드를 잘게 나눌수록 메모화 효과는 더욱 커진다. 어떤 함수라도 내부에 캐시 장치를 달면 프로그램을 빨리 평가하는데 한 몫하기 마련이다.
- 프로그램을 자신과 닮은, 메모화 가능한 작은 하위 작업으로 쪼개는 재귀 역시 분해의 한 종류다. 성능이 좋지 않은 재귀 알고리즘도 메모화를 이용하면 진짜 빠른 알고리즘으로 거듭날 수 있다.

### 7.3.5 재귀 호출에도 메모화를 적용
- 재귀는 떄때로 브라우저를 서서히 죽음으로 몰고 가거나 고약한 예외를 던지게 한다. 엄청 큰 입력을 처리하면서 스택이 비정상적으로 커질 때 이런일이 주로 일어난다. 하지만 메모화를 이용하면 이런 문제를 해결하는데 도움이 될 때가 있다.
- 게승을 계산하는 일처럼 주어진 입력 숫자만큼 프레임 개수가 늘어날 수밖에 없는 경우, 재귀는 스택 공간을 너무 많이 허비하는 경향이 있다. 하지만 메모화를 이용하면 다음 숫자를 계산할 때 필요한 스택 프레임 개수를 엄청나게 줄일 수 있다.

### 7.4 재귀와 꼬리 호출 최적화
- 함수형 언어 중에는 아예 내장 루프문조차 없이 재귀와 메모화로 반복을 대신하는 언어도 있다. 하지만 메모화도 별 도움이 되지 않는 경우가 있는데, 함수 입력이 계속 바뀔 수 밖에 없어 내부 캐시 계층이 제 임무를 수행할 기회조차 없다면 그렇다.
- TCO는 `꼬리 호출 제거` 라고도 하는데, ES6부터 신설된 컴파일러 개선 항목으로서, 재귀 호출 실행을 단일 프레임으로 눌러 펴 실행한다. 물론 재귀 프로그램이 제일 마지막에 다른 함수를 호출할 경우에만 TCO가 일어난다. 이떄 마지막 호출이 꼬리 위치에 있다고 부른다.

## 마치며
- 함수형 코드는 동등한 명령형 코드보다 더 느리게 실행되거나 더 많은 메모리를 점유하는 경우가 있다.
- 조합기로 대체하거나 로대시JS같은 함수형 라이브러리의 도움을 받아 느긋하게 평가하는 지연 전략을 구사할 수 있다.
- 메모화는 내부적인 함수 수준의 캐시 전략으로, 잠재적으로 값비싼 함수를 중복 평가하지 않게 한다.
- 프로그램을 단순 함수로 분해하면, 메모화를 통해 보다 효율적인, 확장 가능한 코드로 개발할 수 있다.
- 분해의 확장판임 재귀는 자기 반복적인, 더 단순한 문제들로 나누어 해법을 찾는 기법이다. 콘텍스트 스택 사용까지 최적화하려면 메모화를 십분 활용한다.
- 꼬리 재귀 함수로 바꾸면 꼬리 호출 최적화라는 컴파일러 확장 기능을 활용할 여지가 생긴다.