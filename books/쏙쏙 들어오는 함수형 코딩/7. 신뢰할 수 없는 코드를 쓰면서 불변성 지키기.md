### 목차
- 레거시 코드나 신뢰할 수 없는 코드로부터 내 코드를 보호하기 위해 방어적 복사를 만든다.
- 얉은 복사와 깊은 복사를 비교한다.
- 카피-온-라이트와 방어적 복사를 언제 사용하면 좋은지 알 수 있다.

### 방어적 복사
우리가 알고있는 카피-온-라이트 패턴은 데이터를 바꾸기 전에 복사한다. 무엇이 바뀌는지 알기 때문에 무엇을 복사해야 할지 예상할 수 있다. 반면 분석하기 힘든 레거시 코드는 어떤 일이 일어날지 정확히 알 수 없다. 그래서 데이터가 바뀌는 것을 완벽히 막아주는 원칙이 필요하다. 이 원칙을 방어적 복사라고 한다.

### 방어적 복사는 원본이 바뀌는 것을 막아준다.
바뀔 수도 있는 데이터가 신뢰할 수 없는 코드에서 안전지대로 들어온다. 들어온 데이터로 깊은 복사본을 만들고 변경 가능한 원본은 버린다. 신뢰할 수 있는 코드만 복사본을 쓰기 떄문에 데이터는 바뀌지 안흔다. 이런 방법으로 들어오는 데이터를 보호할 수 있다.

### 방어적 복사 규칙

#### 규칙1: 데이터가 안전한 코드에서 나갈 떄 복사하기
1. 불변성 데이터를 위한 깊은 복사본을 만든다.
2. 신뢰할 수 없는 코드로 복사본은 전달한다.

#### 규칙2: 안전한 코드로 데이터가 들어올 때 복사하기
1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달합니다.
2. 복사본을 만들어 안전한 코드에서 사용합니다.

### 방어적 복사가 익숙할 수도 있다.
몇가지 예를 들어보자
### 웹 API속에 방어적 복사
대부분의 웹 기반 API는 암묵적으로 방어적 복사를 한다.

JSON 데이터가 API에 요청으로 들어왔다고 생각해보자. 클라이언트는 데이터를 인터넷을 통해 API로 보내려고 직렬화한다. 이떄 JSON 데이터는 `깊은 복사본`이다. 서비스가 잘 동작한다면 JSON으로 응답한다. 이떄 JSON도 역시 깊은 복사본이다. 서비스에 들어올 떄와 나갈 떄 데이터를 복사한 것이다. 이처럼 웹 API는 방어적 복사를 한다. 마이크로 서비스나 서비스 지향 시스템이 서로 통신을 할 때 방어적 복사를 한다는 점은 장점이다. 방어적 복사로 서로 다른 코드와 원칙을 가진 서비스들이 문제없이 통신할 수 있다.


### 카피-온-라이트
#### 언제 쓰나요?
통제할 수 있는 데이터를 바꿀 때 카피-온-라이트를 쓴다.
#### 어디서 쓰나요?
안전지대 어디서나 쓸 수 있다. 사실 카피-온-라이트가 불변성을 가진 안전지대를 만든다.
#### 복사 방식
얉은 복사
#### 규칙
1. 바꿀 데이터의 얉은 복사를 만든다.
2. 복사본을 변경한다.
3. 복사본을 리턴한다.

### 방어적 복사
#### 언제 쓰나요?
신뢰할 수 없는 코드와 데이터를 주고받아야 할 때 방어적 복사를 쓴다.
#### 어디서 쓰나요?
안전지대의 경계에서 데이터가 오고갈 때 방어적 복사를 쓴다.
#### 복사 방식
깊은 복사
#### 규칙
1. 안전지대로 들어오는 데이터에 깊은 복사를 만든다.
2. 안전지대에서 나가는 데이터에 깊은 복사를 만든다.

### 깊은 복사는 얇은 복사보다 비싸다.
얉은 복사는 바뀌지 않은 값이라면 원본과 복사본이 데이터를 공유한다. 하지만 깊은 복사는 원본과 어떤 데이터 구조도 공유하지 않는다.

깊은 복사는 모든 것을 복사한다. 데이터가 변경되면 안되지만, 신뢰할 수 없는 코드가 변경할지도 모른다면 깊은 복사를 사용해야  한다.

깊은 복사는 확실히 비싸다. 그래서 모든곳에 쓰지 않는다. 카피-온-라이트를 사용할 수 없는 곳에서만 사용한다.
