### 목차
- 왜 일급 값이 좋은지 알아본다.
- 문법을 일급 함수로 만드는 방법에 대해 알아본다
- 고차 함수로 문법을 감싸는 방법을 알아본다.
- 일급 함수와 고차 함수를 사용한 리팩터링 두 개를 살펴본다.

### 코드의 냄새: 함수 이름에 있는 암묵적 인자
코드의 냄새는 일급 값으로 바꾸면 표현력이 더 좋아진다. 함수 본문에서 사용하는 어떤 값이 함수에 나타난다면 함수 이름에 있는 암묵적 인자는 코드의 냄새가 된다.

#### 특징
1. 거의 똑같이 구현된 함수가 있다.
2. 함수 이름이 구현에 있는 다른 부분을 가리킨다.

### 리팩터링: 암묵적 인자를 드러내기
함수 이름에 있는 암묵적 인자를 어떻게 명시적인 함수 인자로 바꿀 수 있을까? 암묵적 인자를 드러내기 리팩터링은 암묵적 인자가 일급 값이 되도록 함수에 인자를 추가한다. 이렇게 하면 잠재적 중복을 없애고 코드의 목적을 더 잘 표현할 수 있다.

#### 단계
1. 함수 이름에 있는 암묵적 인자를 확인한다.
2. 명시적인 인자를 추가한다.
3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다.
4. 함수를 호출하는 곳을 고친다.

### 리팩터링: 함수 본문을 콜백으로 바꾸기
언어 문법 중 어떤 문법은 일급이 아니다. 함수 본문을 콜백으로 바꾸기 리팩터링으로 함수 본문에 어떤 부분을 콜백으로 바꾼다. 이렇게 하면 일급 함수로 어떤 함수에 동작을 전달할 수 있다. 이 방법은 원래 있던 코드를 고차함수로 만드는 강력한 방법이다.

#### 단계
1. 함수 본문에서 바꿀 부분의 앞부분과 뒷부분을 확인한다.
2. 리팩터링 할 코드를 함수로 빼낸다.
3. 빼낸 함수의 인자로 넘길 부분을 또 다른 함수로 빼낸다.

### 일급과 일급이 아닌 것 을 구별하기

#### 자바스크립트에서 일급이 아닌 것
1. 수식 연산자
2. 반복문
3. 조건문
4. try/catch

#### 일급으로 할 수 있는 것
1. 변수에 할당
2. 함수의 인자로 넘기기
3. 함수의 리턴값으로 받기
4. 배열이나 객체에 담기

하지만 중요한 것은 일급이 아닌 것을 일급으로 바꾸는 것이다. 일급으로 바꾸는 기술은 함수형 프로그래밍에서 중요하다.

### 객체와 배열을 너무 많이 쓰게 된다.
자바스크립트에서는 객체가 해시 맵과 같은 기능을 해준다. 물론 다른 언어를 사용한다면 다른 기능을 사용해야 한다. 결국 자바스크립트를 사용한다면 전보다 객체를 더 많이 쓴다고 느낄 수 있다.

중요한 것은 데이터를 사용할 때 임의의 인터폐이쓰로 감싸지 않고 그대로 사용하고 있다는 점이다. 인터페이스를 잘 만들면 데이터를 정해진 방법으로만 쓸 수 있다. 하지만 장바구니와 제품 같은 엔티티는 매우 일반적이다. 호출 그래프상에서 가장 아래에 있고, 변하지 않고 일반적으로 많이 재사용하기 때문에 객체와 배열을 사용한다.

데이터를 데이터 그대로 사용하는 것의 중요한 장점은 여러가지 방법으로 해석할 수 있다는 점이다. 제한된 API로 정의하면 데이터를 제대로 활용할 수 없다. 데이터가 미래에 어떤 방법으로 해석될지 미리 알 수 없기 때문에 필요할 때마다 알맞은 방법으로 해석할 수 있어야 한다. 이것을 데이터 지향이라고 한다.

#### 데이터 지향
데이터 지향은 이벤트와 엔티티에 대한 사실을 표현하기 위해 일반 데이터 구조를 사용하는 프로그래밍 형식이다.

## 어떤 문법이든 일급 함수로 바꿀 수 있다.
앞에서 자바스크립트에는 일급이 아닌 것이 많다고 말했었다. + 연산자는 변수에 할당할 수 없다. 하지만 + 연산자와 같은 함수를 만들 수 있다.

```ts
function plus(a, b) {
	return a + b;
}
```
자바스크립트에서 함수는 일급 값이다. 위 코드는 + 연산자를 일급 값으로 만든 것이다. 일급으로 만들면 강력한 힘이 생긴다.

### 일급과 고차함수의 관계
일급은 인자로 전달할 수 있다는 말이고, 고차라는 말은 함수가 다른 함수를 인자로 받을 수 있다는 말이다. 만약 일급 함수가 없다면 고차 함수를 만들 수 없다.

반복분을 일급으로 만들어보자.

#### 준비하고 먹기
```ts
for(var i = 0; i < foods.length; i++) {
	var food = foods[i];
	cook(food);
	eat(food);
}
```

#### 설거지하기
```ts
for(var i = 0; i < dishes.length; i++) {
	var dish = dishes[i];
	wash(dish);
	dry(dish);
	putAway(dish);
}
```

반복문 안에 있는 본문이 여러줄이기 떄문에 함수로 빼내 한 줄로 만들어 보자

```ts
function cookAndEatArray(array) {
	for(var i = 0; i < array.length; i++) {
	var item = array[i];
	cookAndEat(item);
	}
}

function cookAndEat(food) {
	cook(food);
	eat(food);
}

cookAndEatArray();
```

```ts
function cleanArray(array) {
	for(var i = 0; i < array.length; i++) {
		var item = array[i]
		clean(item);
	}
}

function clean(dish) {
	wash(dish);
	dry(dish);
	putAway(dish);
}

cleanArray(dishes);
```


암묵적 인자 냄새를 찾고 리팩터링 해보자

```ts
function forEach(array, f) {
	for(var i = 0; i< array.length; i++) {
	var item = array[i];
	f(item);
	}
}

function clean(food) {
	wash(dish);
	dry(dish);
	putAway(dish);
}


function cookAndEat(food) {
	cook(food);
	eat(food);
}

forEash(foods, clean);
```

forEach 함수는 배열과 함수를 인자로 받는다. 함수를 인자로 받으므로 forEach 함수는 고차함수라고 할 수 있다.

여기서 정리하자면 고차함수는 인자로 함수를 받거나 리턴값으로 함수를 리턴하는 함수를 말하는 것으로 알 수 있다.

forEach를 사용하면 다음과 같다.

```ts
forEach(foods, function(food) {
	cook(food);
	eat(food);	
})
```

forEach는 고차함수다. 고차함수의 장점은 코드를 추상화할 수 있다는 점이다. 반복문 안에 있는 본문은 항상 다르므로 매번 반복문을 만들어야 했다. 하지만 고차함수를 사용하면 반복문에서 다른 부분만 함수로 넘겨주면 된다.

아래 함수를 리팩토링 해보자 함수 본문을 콜백으로 바꾸기 라는 리팩터링을 사용해보자.
```ts
try {
	saveUserData(user);
} catch(error) {
	logToSnapErrors(error);
}
```
결과
```ts
function withLogging(f) {
	try{
		f();
	} catch (error) {
		logToSnapErrors(error);	
	}
}

withLogging(function() { // 왜 함수를 감싸서 익명함수로 넘겨야하나요?
	saveUserData(user);
})
```

왜 함수를 감싸서 넘겨야할까?
함수를 감싼 이유는 바로 실행되면 안되기 때문이다. 이 코드는 마치 얼음 속에 있는 생선처럼 보관되어 있다고 할 수 있다. 이 방법은 함수의 실행을 미루는 일반적인 방법이다.

아래 함수는 감싼 함수를 호출하기 전까지 실행되지 않는다.
```ts
function() {
saveUserData(user);
}
```
자바스크립트에서 함수는 일급이기 떄문에 함수를 정의할 수 있는 방법은 여러가지가 있다. 아래에서 설명하겠다.

#### 이름 붙이기
```ts
var f = function() {
	saveUserData(user);
}
```

#### 컬렉션에 저장하기
```ts
array.push(function() {
	saveUserData(user);
})
```
#### 그냥 넘기기
```ts
withLogging(function() {
	saveUserData(user);
})
```
#### 선택적으로 호출하기
```ts
function callOnThursday(f) {
	if(today === "Thursday")
	f();
}
```
#### 나중에 호출하기
```ts
function callTomorrow(f) {
	sleep(oneDay);
	f();
}
```
#### 새로운 문맥 안에서 호출하기
```ts
function withLogging(f) {
	try {
		f();
	} catch (error) {
		logToSnapErrors(error);
	}
}
```

즉 함수를 전달하는 이유는 함수 안에 있는 코드가 특정 문맥 안에서 실행돼야 하기 떄문이다. 이경우 try catch 문맥 안에서 실행된다. 고차함수를 쓰면 다른 곳에 정의된 문맥에서 코드를 실행할 수 있다. 문맥은 함수이기 떄문에 재사용할 수 있다.

### 함수 이름에 있는 암묵적 인자 냄새의 특징
1. 거의 똑같이 구현된 함수가 있다.
2. 함수 이름이 구현에 있는 다른 부분을 가리킨다.
3. 구현이 비슷하다.
4. 함수 이름에 다른 부분이 함수에서 사용된다.

### 리팩터링 단계
1. 함수 이름에 있는 암묵적 인자를 확인한다.
2. 명시적인 인자를 추가한다.
3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다.
4. 함수를 호출하는 곳을 고친다.

## 결론
- 언어에는 일급이 아닌 기능이 많다 그래서 우리는 일급이 아닌 것들을 함수로 감싸서 일급으로 만들수 있다.
- 고차 함수는 다른 함수에 인자로 넘기거나 리턴값으로 받을 수 있는 함수다. 고차함수로 다양한 동작을 추상화할 수 있다.
- 함수 이름에 있는 암묵적 인자는 함수의 이름으로 구분하는 코드의 냄새다. 암묵적 인자를 드러내기 리팩터링을 적용해 없애자.
- 동작을 추상화하기 위해 본문을 콜백으로 바꾸기 리팩터링을 사용하자. 서로 다른 함수의 동작 차이를 일급 함수 인자로 만든다.