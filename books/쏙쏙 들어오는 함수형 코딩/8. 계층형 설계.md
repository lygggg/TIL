### 목차
- 소프트웨어 설계에 대한 실용적인 정의를 소개합니다.
- 계층형 설계를 이해하고 어떤 도움이 되는지 알아봅니다.
- 깨끗한 코드를 만들기 위해 함수를 추출하는 방법으 배웁니다.
- 계층을 나눠서 소프트웨어를 설계하면 왜 더 나은 생각을 할 수 있는지 알아봅니다.

### 계층형 설계란 무엇인가?
계층형 설계는 소프트웨어를 계층으로 구성하는 기술이다. 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 이용해 정의한다. 설계 감각을 키우면 소프트웨어를 고치고, 읽고, 테스트하고, 재사용하기 쉬운 코드를 만들기 위한 계층 구조가 뭔지 알 수 있다.

- 비즈니스 규칙
- 장바구니를 위한 동작들
- 카피-온-라이트
- 언어에서 지원하는 배열 관련 기능

### 계층형 설계 감각을 키우기 위한 출력
#### 조직화
- 새로운 함수를 어디에 놓을지 결정
- 함수를 다른 곳을 이동
#### 구현
- 구현 바꾸기
- 함수 추출하기
- 데이터 구조 바꾸기
#### 변경
- 새 코드를 작성할 곳 선택하기
- 적절한 수준의 구체화 단계 결정하기

## 계층형 설계 패턴
### 패턴 1: 직접구현
직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다. 너무 구체적이라면 코드에서 나는 냄새다.
### 패턴 2: 추상화 벽
인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있다. 고수준의 추상화 단계만 생각하면 되기 떄문에 두뇌 용량의 한계를 극복할 수 있다.
### 패턴 3: 작은 인터페이스
시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다. 다른 동작도 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.
### 패턴 4: 편리한 계층
계층형 설계 패턴과 실천 방법은 개발자의 요구를 만족시키면서 비즈니스 문제를 잘 풀 수 있어야 한다. 소프트웨어를 더 빠르고 고품질로 제공하는데 도움이 되는 계층에 시간을 투자해야 한다. 코드와 그 코드가 속한 추상화 계층은 작업할 때 편리해야 한다.

아래 함수에 직접 구현 패턴을 적용해보자
```ts
function freeTieClip(cart) {
	var hasTie = false;
	var hasTieClip = false;
	for(var i = 0; i < cart.length; i++) {
		var item = cart[i];
		if(item.name === "tie")
			hasTie = true;
		if(item.name === "tie clip")
			hasTieClip = true;
	}
	if(hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip);
	}
	return cart;
}
```

isInCart 반복문 추출하기
```ts
function freeTieClip(cart) {
	var hasTie = isInCart(cart, "tie");
	var hasTieClip = isInCart(cart, "tie clip");
	if(hasTie && !hasTieClip) {
		var tieClip = make_item("tie clip", 0);
		return add_item(cart, tieClip);
	}
	return cart;
}

function isInCart(cart, name) {
	for(var i = 0; i<cart.length; i++) {
		return true;
	}
	return false;
}
```

freeTieClip에서 사용하는 기본 for loop와 array index 는 자체적으로 자바스크립트에 내장된 기능이다. 하지만 make_item, add_item같은 함수는 직접 만든 함수다. 직접 만든 함수와 언어 기능은 추상화 수준이 다르다. 반복문과 배열 인덱스를 참조하는 기능은 더 낮은 추상화 단계다. 이렇게 한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지  않아서 읽기 어렵다. 하지만 우리는 isInCart라는 함수를 따로 만들어서 비슷한 추상화 단계에 있도록 설계했다. 이제 freeTieClip함수는 장바구니가 배열로 되어있는지를 알 필요가 없어졌다.

### 같은 계층에 있는 함수는 같은 목적을 가져야 한다.
각 계층은 추상화 수준이 다르다. 그래서 어떤 계층에 있는 함수를 읽거나 고칠 때 낮은 수준의 구체적인 내용은 신경쓰지 않아도 된다. 예를 들어 "장바구니 비즈니스 규칙" 계층에 있는 함수를 쓸 때, 장바구니가 배열로 구현되어 있다는 것과 같은 구체적인 내용은 신경 쓰지 않아도 된다.

아래 isInCart와 indexOfItem 함수는 비슷하다. 하지만 indexOfItem함수는 배열의 인덱스는 리턴하는 함수(배열이라는 것을 알아야함)기때문에 isInCart보다 한단계 낮은 수준의 함수다. 그래서 indexOfItem 함수로 isInCart 함수를 만들 수 있다.
```ts
function isInCart(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if(cart[i].name === name)
			return true;
	}
	return false;
}
```

```ts
function indexOfItem(cart, name) {
	for(var i = 0; i < cart.length; i++) {
		if(cart[i].name === name)
			return i;
	}
	return null;
}
```

결과
```ts
function isInCart(cart, name) {
	return indexOfItem(cart, name) !== null;
}
```


## 직접 구현 패턴 리뷰
### 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결합니다.
코드가 서로 다른 구체화 단계에 있다면 읽기 어렵다. 코드를 읽을 때 이해해야 할 것이 많이 있는데 구체화 단계가 다르다면 이해하기 더 어려워진다. 직접 구현하면 코드를 읽기 위해 알아야 하는 구체화 단계의 범위를 줄일 수 있다.
### 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와준다.
코드에 있는 다양한 단서를 통해 구체화 수준에 집중하다 보면 설계 감각을 키울 수 있고 코드를 필요에 알맞게 바꿀 수 있다.
### 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
코드에는 설계를 개선하기 위한 단서가 많이 있다. 호출 그래프는 함수가 서로 어떻게 연결되어 있는지 보여준다. 함수 시그니처와 본문, 호출 그래프와 같은 다양한 단서를 가지고 직접 코드 패턴을 적용할 수 있다.
### 함수를 추출하면 더 일반적인 함수로 만들 수 있다.
함수에 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 빼내는 것이다. 일반적인 함수는 보통 구체적인 내용 하나만 다루기 떄문에 테스트하기 쉽다. 명확한 코드와 알맞은 이름을 가진 함수는 더 읽기 쉽다.
### 일반적인 함수가 많을수록 재사용하기 좋다.
일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있다. 우리는 구현을 명확하게 하기 위해 일반적인 함수를 빼내야한다. 함수를 빼내면 재사용할 수 있는 곳이 보인다.
### 복잡성을 감추지 않는다.
계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 한다. 복잡한 코드를 같은 계층으로 옮기면 안된다. 더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 소프트웨어에 직접 구현 패턴을 적용해보자.

## 결론
- 계층형 설계는 코드를 추상화 계층으로 구성한다. 각 계층을 볼 때 다른 계층에 구체적인 내용을 몰라도 된다.
- 문제 해결을 위한 함수를 구현할 때 어떤 구체화 단계로 쓸지 결정하는 것이 중요하다. 그래야 함수가 어떤 계층에 속할지 알 수 있다.
- 함수 이름은 의도를 알려준다. 비슷한 목적의 이름을 가진 함수를 함께 묶을 수 있다.
- 함수 본문은 중요한 세부 사항을 알려준다. 함수 본문을 함수가 어떤 계층 구조에 있어야 하는지 알려준다.