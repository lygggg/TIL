### 들어가기전에
상속의 첫 번째 용도는 타입 계층을 구현하는 것이다. 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. 타입 계층의 관점에서 부모 클래스는 자식 클래스의 `일반화`이고 자식 클래스는 부모 클래스의 `특수화`다

상속의 두 번째 용도는 `코드 재사용`이다. 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법과 같다. 하지만 재사용만을 위해서 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게될 확률이 높다.

동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다. 상속의 가치는 이러한 타입 게층을 구현할 수 있는 쉽고 편안한 방법을 제공하는데 있다.

> `객체 기반 프로그래밍`이란 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다. 이 정의에 따르면 `객체지향 프로그래밍` 역시 객체기반 프로그래밍의 한 종류다. 객체지향 프로그래밍은 객체기반 프로그래밍과 마찬가지로 객체들을 조합해서 애플리케이션을 개발하지만 `상속`과 `다형성`을 지원한다는 점에서 객체기반 프로그래밍과는 차별화된다. 간단히 말해서 객체지향 프로그래밍은 상속과 다형성을 지원하지만 객체기반 프로그래밍은 지원하지 않는다. 
> 객체기반 프로그래밍이 자바스크립트와 같이 클래스가 존재하지 않는 프로토타입 기반 언어를 사용한다.

### 객체지향 프로그래밍과 타입 계층
객체의 타입을 결정하는 것은 퍼블릭 인터페이스다  
일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.

-   **슈퍼타입** 이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜 상대적으로 범용적이고 **넓은 의미** 로 정의한 것이다.
-   **서브타입** 이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화 시켜 상대적으로 범용적이고 **좁은 의미** 로 정의한 것이다.

### is-a 관계
두 클래스가 어휘적으로 **is-a** 관계를 모델링할 경우에만 상속을 사용해야 한다  
하지만 is-a 관계가 직관적이고 명확하지는 않다

### 행동 호환성
타입 사이에 개념적으로 어떤 연관성이 있다고 하더라도 행동에 연관성이 없다면 is-a 관계를 사용하지 말아야 한다.  
결론은 두 타입 사이에 행동이 호환되는 경우에만 타입 계층으로 묶어야 한다.

행동의 호환 여부를 판단하는 기준은 **클라이언트 관점** 이다.  
클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.  
하지만 클라이언트가 두 타입이 동일하게 행동하지 않을 것이라고 기대한다면 두 타입을 타입 계층으로 묶어서는 안된다.

### 인터페이스 분리 원칙 (ISP)
클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있다.  
대부분의 경우 인터페이스는 **클라이언트의 요구가 바뀜에 따라 변경된다**

클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급효과를 효과적으로 제어할 수 있게 된다.
이처럼 **인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어** 하는 설계 원칙을  
**인터페이스 분리 원칙(Interface Segregation Principle, ISP)** 라고 한다.

### 서브클래싱과 서브 타이핑
-   **서브클래싱(subclassing)** : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
    -   자식 클래스와 부모 클래스의 행동이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
    -   구현상속(implementation inheritance) 또는 클래스 상속 (class inheritance)이라고 부른다
-   **서브타이핑(subtyping)** : 타입 계층을 구성하기 위해 상속을 사용하는 경우
    -   자식클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
    -   서브타이핑을 인터페이스 상속 (interface inheritance) 이라고 한다
    -   서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다
    -   행동 호환성을 만족 시켜야 한다.

### 리스코프 치환 원칙
바바라 리스코프는 올바른 상속 관계의 특징을 정의하기 위해 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)** 을 발표했다.  
상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서는 다음의 조건을 만족해야 한다.

### 유연한 설계의 기반
리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.  
새로운 자식 클래스를 추가하더라도 클라이언트 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.

다시 말해서 클라이언트의 입장에서 퍼블릭 인터페이스와 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다는 것이다.

자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있다면  
기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.  
따라서 리스코프 치환 원칙은 **개방-폐쇄 원칙**을 만족하는 설계를 위한 전제 조건이다.

# 계약에 의한 설계와 서브타이핑
클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 **계약에 의한 설계 (Design By Contract, DBC)** 라고 부른다.

계약에 의한 설계는 사전조건, 사후조건, 클래스 불변식 세 가지 요소로 구성된다.

-   **사전조건(precondition)** : 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 조건
-   **사후조건(postcondition)** : 메서드가 실행된 후에 클라이언트에게 보장해야 하는 조건
-   **클래스 불변식(class invariant)** : 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 하는 조건

리스코프 치환 원칙은 어떤 타입이 서브타입이 되기 위해서는 슈퍼타입의 인스턴스와 협력하는 클라이언트 관점에서  
서브타입의 인스턴스가 슈퍼타입을 대체하더라도 협력에 지장이 없어야 한다는 것을 의미한다

  
따라서 계약에 의한 설계를 사용하면 리스코프 치환 원칙이 강제하는 조건을 계약의 개념을 이용해 좀 더 명확하게 설명할 수 있다.

> **리스코프 치환 원칙과 계약에 의한 설계**
> 
> 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 **계약** 을 준수해야한다.

### 서브타입과 계약
계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다.

계약의 관점에서 볼때 아래의 규칙을 지켜야 한다.
-   서브타입에서 더 강력한 사전조건을 정의할 수 없다.
    -   사전에 슈퍼타입에서 계약한 행동을 위반한다.
    -   예시)
        -   슈퍼타입 메서드의 파라미터는 정수만 들어올 수 있다.
        -   서브타입 메서드의 파라미터는 양수만 들어올 수 있다. (더 강한 사전조건)
            -   슈퍼타입에서는 음수도 들어올 수 있어서 **행동 호환성** 이 맞지 않는다.
-   서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
    -   예시)
        -   슈퍼타입 메서드의 파라미터는 양수만 들어올 수 있다.
        -   서브타입 메서드의 파라미터는 정수만 들어올 수 있다. (더 약한 사전조건)
            -   슈퍼타입을 사용하는 클라이언트는 어차피 양수만 넣을 것이다.
-   서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
    -   예시)
        -   슈퍼타입 메서드의 반환 값은 0보다 큰 값이다.
        -   서브타입 메서드의 반환 값은 1000보다 큰 값이다. (더 강한 사후조건)
            -   슈퍼타입을 사용하는 클라이언트는 어차피 0보다 큰 값이면 된다
-   서브타입에 더 약한 사후조건을 정의할 수 없다.
    -   예시)
        -   슈퍼타입 메서드의 반환 값은 1000보다 큰 값이다.
        -   서브타입 메서드의 반환 값은 0보다 큰 값이다. (더 약한 사후조건)
            -   슈퍼타입을 사용하는 클라이언트는 1000보다 큰 값을 기대하기 때문에 **행동 호환성** 이 맞지 않는다.
