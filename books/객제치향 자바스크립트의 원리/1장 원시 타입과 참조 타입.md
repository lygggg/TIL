## 이장의 목표
자바스크립트에 있는 두 종류의 타입, 즉 원시 타입과 참조 타입에 대해 알아보고 다뤄볼 것이다.


자바스크립트는 전통적인 객체지향 언어를 배운 사람도 쉽게 배울 수 있도록 언어의 중심을 객체에 두고있다. 자바스크립트에서 데이터 대부분은 객체이거나 객체를 통해 접근하는 값이다. 자바스크립트는 함수조차 객체로 표현하며 덕분에 자바스크립트의 함수는 `일급 함수`이다.

자바스크립트에서 객체는 언제든 만들 수 있고 객체의 프로퍼티 또한 원한다면 언제든 추가하거나 제거할 수 있다. 자바스크립트의 객체는 매우 유연하여 다른 언어에서는 쉽게 사용할 수 없었던 독특하고 흥미로운 패턴도 만들 수 있다.

## 타입이란?
자바스크립트에 클래스라는 개념은 없지만 이를 대체할 타입이라는 개념이 존재하며, 타입은 크게 두 종류로 구분한다. 하나는 단순한 데이터를 저장하는 원시 타입이고 다른 하나는 객체로서 저장되는` 참조 타입`이다. 참조 타입은 사실 메모리상의 주소를 가리킨다.

다른 프로그래밍 언어는, 원시 타입은 스택에 저장하고 참조는 힙에 저장하여 원시 타입과 참조 타입을 구분하고 있지만 자바스크립트는 `변수 객체`의 스코프를 따라 변수를 추적한다. 원시 타입의 원시 값은 바로 변수 객체에 저장되지만 참조 타입에서 변수 객체에 저장되는 참조 값은 메모리에 있는 실제 객체를 가리키는 포인터다.


## 원시 타입
- Boolean
- Number
- String
- Null
- Undefined

모든 원시 타입에는 값을 표현하는 리터럴 형식이 있다. `리터럴`이란 코드에 직접 입력된 이름이나 가격처럼 변수에 저장되지 않을 값을 의미한다.

다른 많은 언어와 마찬가지로 자바스크립트 변수에는 원시 타입의 값이 바로 저장된다. 원시 값을 변수에 할당하면 값이 변수로 복사된다. 다시 말해 등호 기호를 사용해 어떤 변수를 다른 반수에 할당하면 두 변수 모두 자신만의 데이털르 가지게 된다는 뜻이다.

원시 값을 가지고 있는 각 변수는 독립된 저장 공간을 사용하기 떄문에 다른 변수의 값을 바꿔도 영향을 받지 않는다.
```js
var color1 = "red";
var color2 = color1;

console.log(color1); // "red"
console.log(color2); // "red"

color1 = "blue";

console.log(color1); // "blue"
console.log(color2); // "red"
```

color1의 값은 "blue"로 바뀌었지만 color2는 여전히 원래대로 "red"를 유지한다.

## 원시 타입 종류 확인
원시 타입의 종류는 `typeof` 연산자를 사용해 확인할 수 있다. typeof 연산자를 변수에 사용하면 변수에 저장된 데이터의 타입을 문자열로 반환한다. 모든 타입 다 정상적으로 작동하지만 null은 좀 까다롭다.

```js
console.log(typeof null); // "object"
```

왜 null을 실행하면 object일까? 이부분은 설계에서부터 잘못 된 것이다. 이런 특성 떄문에 null인지 아닌지를 확인할 떄는 다음과 같이 비교하는 것이 가장 좋다.
```tsx
console.log(value === null);
```


## 참조 타입
참조 타입은 자바스크립트 객체를 나타내며 클래스가 없는 자바스크립트라는 언어에서 클래스와 가장 가까운 개념이다. 참조 값은 참조 타입의 `인스턴스`이며 객체와 같은 말이다. 객체는 순서가 없는 `프로퍼티`로 이루어져 있으며 프로퍼티는 이름과 값으로 구성되어 있다. 프로퍼티의 값이 함수일 때 이 프로퍼티를 가리켜 `메소드`라고 부른다. 사실 자바스크립트에서 함수 잧는 참조 값이므로 배열을 포함하고 있는 프로퍼티와 함수를 포함하고 있는 프로퍼티 사이에서 함수는 실행이 가능하다는 점만 뺴면 차이가 거의 없다.

## 객체 생성
자바스크립트 객체를 단순 해시테이블로 생각해보면 이해에 도움이 된다.

객체를 만드는 것을 가리켜 `인스턴스화`한다고 하는데 자바스크립트에서 인스턴스화 방법은 두 가지가 있다. 첫 번쨰 방법은 new 연산자와 `생성자`를 사용하는 것이다.

## 객체 참조 제거
자바스크립트는 가비지  컬렉션 기능이 있는 언어이므로 참조타입을 사용할 때 메모리 할당에 대해 고민하지 않아도 된다. 하지만 가비지 컬렉터가 메모리를 해제할 수 있도록 사용하지 않는 객체에 대해서는 `참조 제거`를 해두는 편이 좋다. 참조 제거를 할 때는 객체 변수에 null을 할당하는 방식이 가장 좋다.

## 내장 타입 인스턴스화
자바스크립트에는 Object 타입 외에도 언어에서 기본적으로 제공하는 유용한 내장 참조 타입이 몇 가지 더 있다. 다른 내장 타입은 조금 더 특수한 용도로 사용할 수 있으며 언제든 인스턴스로 만들 수 있다.

- Array
- Date
- Error
- Function
- Object
- RegExp

## 리터럴 형식
리터럴은 new 연산자와 객체의 생성자를 사용하여 명시적으로 객체를 만들지 않고도 참조 값을 만들 수 있는 문법이다.

## 객체 및 배열 리터럴
객체는 중괄호 안에 새로 만들 객체의 프로퍼티를 정의하는 `객체 리터럴` 문법을 사용해 만들 수 있다. 프로퍼티는 이름, 콜론, 값으로 이루어지며 프로퍼티 사이는 쉼표로 구분한다.

```js
var book = {
	name: "객체지향 자바스크립트의 원리",
	year: 2014
};
```
위 코드는 논리적으로 아래 코드와 동일하다.

```js
var book = new Object();
book.name = "객체지향 자바스크립트의 원리"
book.year = 2014;
```

배열도 똑같다.
```js
var colors = ["red", "blue", "green"];
console.log(colors[0]);
```

```js
var colors = new Array("red", "blue", "green")
console.log(colors[0]);
```

함수도 똑같다.
```js
function reflect(value) {
	return value;
}

var reflect = new Function("value", "return value");
```

## 원시 래퍼 타입
원시 래퍼 타입은 세 종류가 있는데 (String, Number, Boolean) 이들은 마치 객체를 다루듯 원시 값을 쉽게 사용할 수 있도록 지원하기 위해 만들어졌다.

원시 래퍼 타입은 문자열, 숫자, 불리언 값을 읽을 때 언어 내부에서 자동으로 만들어진다.

예를들어 다음 코드의 첫 번쨰 줄은 원시 문자열 값을 name 변수에 할당한다. 두 번째 줄은 name을 마치 객체처럼 다뤄서 점 표기법을 사용해 charAt(0) 메소드를 호출했다.

```js
var name = "Nicholas";
var firstChar = name.charAt(0);
console.log(firstChar); // "N"
```

내부에서 일어나는 일은 다음과 같다.
```js
var name = "Nicholas";
var temp = new String(name);
var firstChar = temp.charAt(0);
temp = null;
console.log(firstChar);
```

앞서 두 번째 줄에서 원시 문자열을 객체처럼 취급했기 떄문에 자바스크립트 엔진은 charAt(0) 코드가 정상적으로 동작하도록 String의 인스턴스를 만든다. 이렇게 작성한 String 객체는 한 문장만 실행하고 곧 다시 파괴되는데 이 과정을 가리켜 `오토박싱`이라고 한다.

```tsx
var name = "Nicholas"
var temp = new String(name);
temp.last = "Zakas";
temp = null;

var temp = new String(name);
console.log(temp.last);
temp = null;
```
위에서 보든 새로 추가한 프로퍼티는 문자열이 아니라 임시로 만들어졌다가 파괴되는 객체에 추가된다. 추가한 프로퍼티에 접근할 때 내부적으로는 새로운 객체가 만들어지므로 앞서 추가했던 프로퍼티는 존재하지 않게 된다. 원시 값에 대한 참조 값이 자동으로 만들어짐에도 불구하고 원시 값에 instanceof를 사용해 확인하면 결과는 false가 된다.

```js
var name = "Nicholas";
var count = 10;
var found = false;

console.log(name instanceof String); // false
console.log(count instanceof Number); // false
console.log(found instanceof Boolean);  // false
```

임시 객체는 값을 읽을 때만 만들어지기 떄문에 instanceof 연산자는 false를 반환한다. 물론 원시 래퍼 타입을 명시적으로 사용해 값을 생성하는 방법도 있지만 이때는 다른 문제가 발생한다.

```js
var name = new String("Nicholas");
var count = new Number(10);
var found = new Boolean(false);

console.log(typeof name); // object
console.log(typeof cound); // object
console.log(typeof found); // object
```
원시 래퍼 타입의 인스턴스를 만들면 객체가 만들어지기 떄문에 typeof 연산자를 사용한 결과는 의도한 것과 다르게 나타난다.


## 요약
자바스크립트에는 클래스가 없는 대신 타입이 존재한다. 각 변수나 데이터에는 그에 해당하는 특수한 원시 또는 참조 타입이 존재한다. 다섯 가지 원시타입은 주어진 컨텍스트 내에서 변수 객체에 바로 저장되는 단순한 값을 의미한다. typeof 연산자를 사용하면 원시 타입의 종류를 확인할 수 있지만 null은 null과 비교해야 알 수 있다.

참조 타입은 클래스가 없는 자바스크립트에서 클래스와 가장 가까운 개념이며 객체는 참조 타입의 인스턴스다. new 연산자나 리터럴 형식을 사용하면 새로운 객체를 생성할 수 있다. 프로퍼티와 메소드에 접근할 때는 보통 점 표기법을 사용하는데 각괄호 표기법을 대신 사용할 수 있다. 자바스크립트에서는 함수도 객체이며, 어떤 값이 함수인지는 typeof 연산자를 사용해 확인할 수 있다. instanceof 연산자는 주어진 객체가 어떤 참조 타입의 인스턴스인지 확인할 떄 사용한다.

자바스크립트에는 String, Number, Boolean 이라는 세 종류의 원시 래퍼 타입이 있어 원시 값을 마치 참조 값처럼 다룰 수 있다.자바스크립트는 이러한 원시 래퍼 타입을 자동으로 생성하여 일반적일 객체를 다루듯 원시 값을 사용할 수 있도록 해주지만, 자동으로 생성한 임시 객체는 문장 하나를 완료하자마자 곧 파괴된다. 원시 래퍼 타입의 인스턴스를 명시적으로 만들 수 도 있지만 이 방법은 혼란을 야기할 소지가 있어 권장하지 않는다.