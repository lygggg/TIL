## 리액트 렌더링

리액트의 기본적인 동작은 부모 컴포넌트가 렌더링되면, 리액트는 모든 자식 컴포넌트를 순차적으로 리렌더링한다.

예를 들어, **`A > B > C > D`** 순서의 컴포넌트 트리가 있다고 가정해보자. **`B`**에 카운터를 올리는 버튼이 있고, 이를 클릭했다고 가정해보자.

1.  **`B`**의 **`setState()`**가 호출되어, B의 리렌더링이 렌더링 큐로 들어간다.
2.  리액트는 트리 최상단에서 부터 렌더링 패스를 시작한다.
3.  **`A`**는 업데이트가 필요하다고 체크 되어 있지 않을 것이므로, 지나간다.
4.  **`B`**는 업데이트가 필요한 컴포넌트로 체크되어 있으므로, B를 리렌더링 한다. **`B`**는 **`C`**를 리턴한다.
5.  **`C`**는 원래 업데이트가 필요한 것으로 간주되어 있지 않았다. 그러나, 부모인 **`B`**가 렌더링 되었으므로, 리액트는 그 하위 컴포넌트인 **`C`**를 렌더링 한다. **`C`**는 **`D`**를 리턴한다.
6.  **`D`**도 마찬가지로 렌더링이 필요하다고 체크되어 있지 않았지만, **`C`**가 렌더링된 관계로, 그 자식인 **`D`**도 렌더링 한다.

즉 컴포넌트를 렌더링 하는 작업은, 기본적으로, 하위에 있는 모든 컴포넌트 또한 렌더링하게 된다.

한가지 기억해둬야 할 것은, 렌더링이 꼭 나쁜것이 아니다. 단지 리액트가 실제로 DOM을 변경해야 하는지 여부를 확인하는 것 뿐이다.

### 리액트 렌더링 규칙

리액트 렌더링의 중요한 규칙 중 하나는 순수해야하고 부수작용이 없어야 한다. 예를들어 `console.log` 도 부수작업을 야기하지만, 그 어떤 것도 망가트리지 않는다. `props` 가 변경되는 것은 명백한 부수효과이며, 무언가를 망가트릴 수 있다. 렌더링 중간에 ajax 호출 또한 부수효과를 일으키고, 이는 요청의 종류에 따라서 명백하게 앱에 예기치 못한 결과를 야기할 수 있다.

**[Rules of React](https://gist.github.com/sebmarkbage/75f0838967cd003cd7f9ab938eb1958f)** 라는 글이 있다. 이 글에서는, 렌더링을 표함한 다양한 리액트의 라이프 사이클 메소드의 동작과, 어떠한 동작이 '순수' 한지, 혹은 안전한지를 나타내고 있다. 요약하면

렌더링 로직이 할 수 없는 것

-   존재하는 변수나 객체를 변경해서는 안된다.
-   **`Math.random()`** **`Date.now()`**와 같은 랜덤 값을 생성할 수 없다.
-   네트워크 요청을 할 수 없다.
-   state를 업데이트

렌더링 로직은

-   렌더링 도중에 새롭게 만들어진 객체를 변경
-   에러 던지기
-   아직 만들어지지 않은 데이터를 lazy 초기화 하는일(캐시)

### 컴포넌트 메타데이터와 fiber

리액트는 애플리케이션에 존재하는 모든 현재 컴포넌트 인스턴스를 추적하는 내부 데이터 구조를 가지고 있다. 이 데이터 구조의 핵심적인 부분은, 다음과 같은 메타데이터 필드를 포함하고 있는 Fiber라고 불리는 객체다.

렌더링 패스 동안, 리액트는 fiber 객체의 트리를 순회하고, 새로운 렌더링 결과를 계산한 결과로 나온 업데이트된 트리를 생성한다.

fiber 객체는 실제 컴포넌트의 prop와 state값을 저장하고 있다. 여기서 fiber에 대해서 다루지는 않겠다.

### 컴포넌트 타입과 재조정

리액트는 기존 컴포넌트 트리와 DOM 구조를 가능한 많이 재사용함으로써 리렌더링의 효율성을 추구한다. 동일한 유형의 컴포넌트, 또는 HTML 노드를 트리의 동일한 위치에 렌더링하도록 리액트에 요청하게되면, 리액트는 해당 컴포넌트 또는 HTML 노드를 만드는 대신에 해당 업데이트만 적용한다. 즉, 리액트에 해당 컴포넌트 타입을 같은 위치에 렌더링 하도록 계속 요청이 있다면, 리액트는 계속 컴포넌트의 인스턴스를 유지한다는 뜻이다.

그러면 리액트는 어떻게 결과물이 실제로 변경된 시기와 방법을 알 수 있을까?

리액트 렌더링 로직은 elements를 그들의 `type` 필드를 기준으로 먼저 비교하는데, 이때 `===` 를 사용한다. 만약 지정된 element가 `div` 에서 `span` 으로, 또는 `<ComponentA/>` 에서 `<ComponentB/>` 로 변경된 경우, 전체 트리가 변경되었다고 가정하여 비교 프로세스의 속도를 높인다. 결과적으로는 리액트는 모든 DOM 노드를 포함한 기존 컴포넌트 트리를 삭제하고 새로운 컴포넌트 인스턴스를 처음부터 다시 만든다.

즉, 렌더링 동안에는 절대로 새로운 컴포넌트 타입을 만들어서는 안된다. 새로운 컴포넌트 타입을 만들게 되면, 이는 참조가 다르고, 리액트가 하위 컴포넌트 트리를 모두 파괴하고 새로운 트리를 만들게 된다.