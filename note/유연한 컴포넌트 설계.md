### css 의존성 주입
### 제어 역전
### compound component, headlees ui, 컴포넌트 추상화 단계
### 좋은 설계란 무엇인가? 객체지향 관점 함수형 관점
### 유연성 트레이드오프 가독성 팀원과의 조율이 필요하다. 부작용을 고려해서 기술을 적용해야한다.
hover 액티브 사용성에 얼마나 중점을 뒀는지? 이쁜게아니라
페이지가 전환될때 트랜지션을 넣었을때 차이
이쁘게 만드는 것보단 헷갈리지 않게 만드는게 중요하다.
그래도 이쁜게 아예 안중요하다는 것은 아니다.
내가 더 나은 엔지니어가 되기위해서 투자를 하는 것
공부를 하는 것도 투자 투자를 하는 목적도 좋은 엔지니어가 되기위한 것
학습의 원동력을 정하면 좋음 발표같은?
엔지니어에 대한 자세


이 글은 제가 어떤 문제를 만났고, Compound Component 패턴을 적용함으로써 제가 겪고 있던 문제를 해결할 수 있었던 경험을 공유하기위해서 작성하게 되었습니다. 해당 패턴이 무엇인지와 제가 패턴을 프로젝트에 적용해봄으로써 제가 얻을 수 있었던 것과, 이 패턴을 선택한 이유가 객체지향 관점에서 어떤 이점이 있는지 살펴보겠습니다.

### 유연한 설계
우리가 생각하는 유연한 설계란 무엇일까요? 유연하면 좋은 설계라고 할 수 있을까요? 우리는 좋은 설계가 무엇인지 부터 알아볼 필요가 있습니다.

>좋은 설계란 무엇인가? 우리가 짜는 프로그램은 두 가지 요구사항을 만족시켜야 한다. 우리는 오늘 완성해야 하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다. 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. -오브젝트-

>  좋은 설계는 나중에라도 변경할 수있는 여지를 남겨놓는 설계다. 설계를 하는 목적은 나중에 설계하는 것을 허용하는 것이며, 설계의 일차적인 목표는 변경에 소요되는 비용을 낮추는 것이다. -객체지향의 사실과 오해-

좋습니다. 위에 나와있는대로 변경할 여지가 있는, 유연한 설계가 좋은 설계라는 말이 맞는 것 같습니다. 즉 기능을 온전하게 수행하는 것은 물론이고, 변경에 유연하게 대처할 수 있도록 설계한다면 좋은 설계라고 할 수 있을 것 같습니다. 그렇다면 우리는 왜 유연하게 설계를 해야할까요? 코드가 유연하면 과연 장점만 존재하는 걸까요?

### 왜 유연한 설계가 필요한가?
설계를 하는데에 투자되는 시간은 개발자에게 비용입니다. 그럼에도 개발자는 왜 좋은 설계를 하는게 중요한걸까요? 

왜냐하면 우리의 소프트웨어는 끊임없이 변하기 때문입니다. 소프트웨어는 사용자에게 서비스를 제공하고, 사용자의 요구사항에 맞춰서 소프트웨어는 끊임없이 발전합니다. 
실제로 개발자들은 서비스를 만드는 시간보다 유지보수에 투자하는 시간이 더 많은 것으로 알고 있습니다. 하지만 요구사항을 변경하는데에 시간이 너무 오래 걸린다면, 사용자의 불만은 쌓일 것이고, 개발자 입장에선 엄청난 스트레스와 비용을 소모하게 될 것입니다. 결국 우리는 변화에 빠르게 대처할 수 있는 유연한 소프트웨어를 설계해야합니다.

그렇다면 하나 궁금한점이 생깁니다.
> 그럼 어떻게 변경에 유연하게 대응할 수 있는 Component를 만들수 있을까요?

 저 역시도 React를 사용하면서 컴포넌트를 어떻게 설계하면 좋을지에 대해서 계속해서 고민해왔습니다. 아래서부터는 제가 Compound Component 패턴이 무엇인지, 어떠한 이유때문에 해당 패턴을 사용했는지에 대해서 다뤄보겠습니다.

### Compound Componenet Pattern
해당 패턴을 살펴보기전에 Compound Component Pattern의 이름에서 Compound가 무엇인지에 대해서 이해해보면 좋을 것 같습니다. Compound는 "합성의", "복합체" 라는 뜻을 가지고 있습니다. 해당 단어로 의미하는 것을 생각해보면 컴포넌트를 합성하는 패턴이라고 이해하면 좋을 것 같습니다. 

[SOSOLOG에서 가져온 예시입니다.](https://so-so.dev/react/design-system-decision-record/)
![](https://velog.velcdn.com/images/baayoo90/post/209a11b2-b825-4eda-bb29-f7736b62e639/image.png)

```tsx
<Select
  label="Your favorite framework/library"
  placeholder="Pick one"
  value={value}
  onChange={...}
  data={[
    { value: 'react', label: 'React' },
    { value: 'ng', label: 'Angular' },
    { value: 'svelte', label: 'Svelte' },
    { value: 'vue', label: 'Vue' },
   ]}
  radius={4}
  inputWraper={<input />}
  shouldCreate={true}
  creatable={true}
  allowDeselect={false}
  {...props}
/>
```
사용자의 요구사항이 계속해서 추가되면서 컴포넌트에 있는 인터페이스(props)가 거대해지는 경우를 모두 경험하셨을거라 생각합니다. Select 컴포넌트는 제대로 동작하지만, 많은 문제가 있습니다. 아래에서 어떤 문제가 있는지 이야기해보겠습니다.

먼저 제가 생각하기에 Select 컴포넌트의 문제점은 인터페이스(props)가 너무 많고, 명확하지 않기 떄문에 어떤 역할을 하는지 이해하기 어렵다는 점입니다. 당장에는 사용하기에 불편함이 없을지는 몰라도, 기능이 계속해서 추가될경우 불필요한 인터페이스가 계속해서 추가되고, 예측할 수 없는 컴포넌트가 될 것이라고 생각합니다. 이는 인터페이스 분리의 원칙에도 맞지않다고 생각합니다. 인터페이스 분리의 원칙이 어떤것인지는 아래에서 설명하겠습니다.

### 인터페이스와 구현의 분리 원칙
해당 원칙에 알아보기전에 좋은 객체가 무엇인지 부터 알고 넘어가겠습니다. 

#### 왜 좋은 객체가 무엇인지 알아야하나요?
좋은 객체는 좋은 컴포넌트와 유사하다고 생각합니다. 자바스크립트 함수는 일급 객체이고, 우리가 사용하는 컴포넌트는 function 컴포넌트이기 때문입니다. 이제 다시 한번 생각해봅시다. 좋은(훌륭한) 객체란 무엇일까요?

> 훌륭한 객체란 구현을 모른채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다. 이것은 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체 내부의 숨겨지는 구현을 명확하게 분리해서 고려해야 한다는 것을 의미한다. -객체지향의 사실과 오해-

우리는 객체지향에서 이것을 인터페이스와 구현의 분리원칙이라고 합니다.

즉 우리는 훌륭한 컴포넌트를 설계해야합니다. 하지만 무분별한 인터페이스가 많아지고, 불 분명해질경우 컴포넌트가 어떤 책임을 가지고있는지 판단하기 어렵고, 훌륭한 컴포넌트가 아닐 확률이 크다고 생각합니다.

하지만 위에서 봤던 것처럼 우리가 작성한 컴포넌트의 인터페이스는 클라이언트의 요구가 바뀜에 따라 끊임없이 변경됩니다. 그렇기 때문에 우리는 더 신경써서 컴포넌트가 정말 필요로하고, 명확하면서, 최소한의 인터페이스만 사용해야합니다. 이것을 객체지향에서는 인터페이스 분리의 원칙(ISP)이라고 부릅니다.

그렇다면 Compound Component pattern을 적용했을 때는 뭐가 다를까요? 코드 예시를 보겠습니다.

```tsx
<Select value={value} onChange={...}>
  <Select.Label>
    Your favorite framework/library
  </Select.Label>
  <Select.Trigger>
    <Input style={{borderRadius: 4}} placeholder='Pick one' />
  </Select.Trigger>
  <Select.Content creatable>
    <Select.Option value='react'>React</Select.Option>
    <Select.Option value='ng'>Angular</Select.Option>
    <Select.Option value='vue'>Vue</Select.Option>
  </Select.Content>
</Select>
```
어떤가요? 제가 생각했을때 패턴을 적용한 후는 그전보다 최소한의 인터페이스(props)를 실제 필요한 곳에서 직접 드러내고 있으므로 명확하고, 예측가능한 컴포넌트를 설계할수 있습니다. 우리는 결론적으로 Compound Component pattern을 적절하게 사용함으로써 우리는 인터페이스 분리의 원칙을 지켰다고 할 수 있습니다! 하지만 장점은 이게 끝이 아닙니다. 아래에서 계속 설명하겠습니다.

### 개방폐쇄의 원칙
앞선 문단에서 컴포넌트는 사용자의 요구사항에 맞춰 계속해서 변경된다고 했습니다. 하지만 제가 기존에 작성했던 컴포넌트들은 유연한 설계가 되어있는 컴포넌트라고 부르기엔 애매했습니다. 아래에서 코드 예시를 살펴보겠습니다.

```ts
interface Props {
    isOpen: boolean;
    title: string;
    buttonLabel: string;
    onClickButton: (e: MouseEvent) => void;
    isChecked?: boolean;
    checkBoxLabel?: string;
    onClickCheckBox? : (e: MouseEvent) => void;
    descriptionList?: string[]
}

function Dialog({ 
        isOpen, 
        title, 
        buttonLabel, 
        onClickButton, 
        isChecked, 
        checkBoxLabel, 
        onClickCheckBox, 
        descriptionList 
    }: Props){
     if (!isOpen){
        return null;
    }
    return React.createPortal(
        <div>
            <span>{title}</span>
            {descriptionList && descriptionList.map(desc => <span key={desc}>{desc}</span>)}
            {checkBoxLabel && <div>
                <input checked={isChecked} onClick={onClickCheckBox} type="checkbox" id="dialog_checkbox">
                <label for="dialog_checkbox">{checkBoxLabel}</label>
            </div>}
            <button onClick={onClickButton}>{buttonLabel}</button>
        </div>
    ,document.body)
}
```
컴포넌트가 확장될때마다 props가 계속해서 추가되고있습니다. 컴포넌트 안에서 유연하게 대응하기 위해서 props를 추가하고, 조건 연산자를 사용하고있습니다. 여기까지는 아무 문제가 없어보입니다. 하지만 descriptionList를 checkBox 아래에서 보여주는 컴포넌트를 만들어달라는 요구사항이 들어온다면, 기존의 Dialog 컴포넌트를 재사용하기 위해서 props를 추가하고, 기존의 코드를 수정하는 방법으로 다시 재사용할 수 있도록 만들 것입니다.

### 그럼 문제가 없는거아닌가요?
계속해서 요구사항이 달라진다면 이에따라 props가 많아지고, 이것을 사용하는 코드는 점점 복잡해집니다. 당연히 기능을 확장하는데 어려움을 겪을 수 밖에 없습니다. 우리의 코드는 수정에는 닫혀있고, 확장에는 열려있어야합니다. 이것을 개방폐쇄원칙이라고 합니다. 하지만 우리의 코드는 컴포넌트에서 기능을 확장하기 위해서 기존의 코드를 수정하는 작업이 빈번하게 일어납니다. 즉 개방폐쇄원칙을 지키고있지 때문에 발생하는 문제입니다.

### 그럼 이 문제를 어떻게 해결할 수 있을까요? 
앞서 말했듯이 Compound Component pattern을 적절히 사용하면 개방폐쇄원칙을 지킬수 있습니다. 

우리는 Compound Component pattern를 적절하게 사용함으로써 우리가 원하는 유연한 컴포넌트를 설계할 수 있었습니다. 그렇다면 해당 패턴의 어떤 특징으로 인해 컴포넌트를 유연하게 설계할 수 있었던 것일까요?

### 제어역전(IOC)
우리는 먼저 제어역전이 무엇인지부터 알아볼 필요가 있습니다. 제어역전이 뭘까요?
> 전통적인 프로그래밍 방식에선 일반적인 일들을 처리하기 위해 개발자의 코드가 라이브러리를 호출하였으나, 제어의 역전을 사용하면 라이브러리에서 개발자의 코드를 호출하게 됩니다.-위키피디아-

음 그렇군요! 단순하게 말하면 개발자의 코드가 라이브러리를 호출하던 방식에서 라이브러리에서 개발자의 코드를 호출하는 방식으로 개발자 -> 라이브러리로 제어를 역전시키는 것을 제어역전의 한 형태라고 볼 수 있는 것입니다. 그러기 위해선 우리는 제어를 적절히 추상화하고, 개별 제어의 차이점만 외부에서 주입받아야합니다. 아래에서 이해를 돕기 위해서 제어역전의 예시를 몇개 들겠습니다.

첫 번째 제어 역전은 우리가 흔히 알고있는 훅(hook)이라는 개념과도 많이 비슷하다고 할 수 있습니다.

#### 그렇다면 훅(hook)은 무엇이고, 제어역전이랑 어떤 관련이 있는 건가요?

> 일반적으로 우리가 사용하는 프레임워크에서는 일반적인 해결책만 제공하고, 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 그리고 이렇게 완성되지 않은 채로 남겨진 동작을 우리는 훅(hook)이라고 부른다. 이렇게 완성된 훅은 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출된다.

즉 훅(hook)은 모든 애플리케이션의 공통적인 부분만 남겨놓고, 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워두고, 비워둔 동작은 의존성 주입(DI)를 통해 외부에서 주입받는 방법으로 hook과 애플리케이션간의 결합도를 낮추고, 유지보수성을 높이는 하나의 동작 방식이라고 할 수 있습니다.

### 훅(hook)? 그럼 커스텀 훅(Custom Hook)도 제어역전의 개념이 있는건가요?
맞습니다. 우리가 자주 사용하는 Custom Hook 방식도 제어역전의 개념을 따르고 있습니다. 아래에서 커스텀 훅의 예시 코드를 살펴보겠습니다. 

```ts
import { useEffect } from 'react';

function useOutSideClick(ref, callback) {
  useEffect(() => {
    const handleClick = (event) => {
      if (ref.current && !ref.current.contains(event.target)) {
        callback?.();
      }
    };

    window.addEventListener('mousedown', handleClick);

    return () => window.removeEventListener('mousedown', handleClick);
  }, [ref, callback]);
}

export default useOutSideClick;
```

useOutSideClick은 호출하는 컴포넌트마다 달라지는 ref, callback을 props로 받아오고 있습니다. 또한 useOutSideClick 함수가 필요로하는 코드를 직접 생성하지 않고, 사용하는 컴포넌트 즉 외부에서 주입받아 사용하는 방식으로 구현되어있습니다. 

정리하자면 useOutSideClick 함수는 개별 제어의 차이점만 외부에서 주입받는 방식으로 외부 컴포넌트에 제어를 위임함으로써 어느 컴포넌트에도 대응할 수 있는 유연한 훅이라고 할 수 있을 것 같습니다. 여기서도 함수가 하던 역할중 일부분을 의존성 주입을 통해 개발자에게 위임한셈이 되니, 제어역전의 한 형태라고 볼수 있습니다.


두번째 우리가 사용하는 React도 제어역전의 개념을 따르고 있습니다. 

> 제어를 위임하는 것, 우리 모두는 뛰어난 운전사일 수 있다. 만약 택시를 탔을때 그 운전기사가 운전을 굉장히 잘한다. 그러면 우리는 그 택시에 타기만해도 밖에서는 뛰어난 운전수가 운전하고 있다고 생각한다. 차의 입장에서 보면 누가 타도 상관없이 뛰어난 운전수로 보인다는 것이다. 제어를 운전을 잘하는 운전기사 아저씨가 대체해주기 떄문이다. 나는 목적지를 이야기해주고, 돈을주는 것만 할뿐이다.

리액트의 어떤 부분이 제어역전이 되었다고 말할수 있는 걸까요? 일단 React에서 렌더링을 제어하는 방식에 대해서 먼저 살펴보겠습니다.

React는 컴포넌트의 상태(state)나 속성(props)의 변화를 감지하고, 그에따라 새로운 Virtual DOM을 생성하는 방식입니다. 그리고 이전의 Virtual DOM과 새로운 Virtual DOM을 비교하여 변경된 부분만을 실제 DOM에 반영합니다. 즉 개발자는 언제 렌더링이될 것인지에 대해서 전혀 신경쓰지않아도 됩니다. 그저 상태만 변경하면 React가 상태 변경을 감지하고, 렌더링을 제어해주는 것입니다. 즉 React에서 제어역전의 개념은, Virtual DOM과 JSX를 사용하여 React가 컴포넌트의 렌더링을 제어하고 있다는 것입니다. 


정리하자면 React 컴포넌트는 자신이 렌더링되는 방식을 직접 제어하는 것이 아니라. React가 원하는 시점에 렌더링이 이루어지는 것입니다. 이는 React를 사용하는 코드를 비교하면 명확하게 알 수 있을 것이라고 생각합니다.




그렇기 때문에 개발자는 렌더링이 어떻게 되는지 이해할 필요없고, 그저 상태를 변경하면 렌더링이 된다는 것을 알고있을 뿐입니다. 이렇게 제어 역전을 통해 책임을 분리하는 방식은 코드를 좀 더 "선언적"으로 작성할 수 있게 해주며, React에서 지향하는 방식과도 동일합니다.




### 의존성 주입

### compound Component는 왜 IOC인가?
https://yeoulcoding.me/325