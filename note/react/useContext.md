### TL;DR

### Context와 Redux는 같은 것인가요?

아니다. 서로 다른 작업을 수행하는 서로 다른 도구이며, 서로 다른 목적으로 사용한다. 컨텍스트는 "상태 관리" 도구입니까?

아니요. 컨텍스트는 form of Dependency Injection의 형태다. 그것은 전송 메커니즘이며 아무것도 관리하지 않는다. 모든 "상태 관리"는 일반적으로 `useState/useReducer`를 통해 사용자와 사용자 자신의 코드에 의해 수행된다.

### 컨텍스트 및 useReducer는 Redux를 대체하나요?

아니요 일부 유사점과 중복이 있지만 기능에는 큰 차이가 있다.

### 언제 컨텍스트를 사용해야 하나요?

구성 요소의 각 수준을 통해 해당 값을 props로 전달하지 않고 React 구성 요소의 트리의 일부에 액세스할 수 있도록 만들고 싶은 값이 있을 때 마다

### 컨텍스트 및 useReducer는 언제 사용해야 합니까?

애플리케이션의 특정 섹션 내에서 적당히 복잡한 React 구성 요소 상태 관리가 필요한 경우

### 대신 언제 Redux를 사용해야 하나요

다음과 같은 경우에 가장 유용하다.

-   앱의 여러 위치에서 필요한 더 많은 양의 애플리케이션의 상태가 있다.
-   시간 경과에 따라 앱 상태가 자주 업데이트 된다.
-   해당 상태를 업데이트하는 논리는 복잡할 수 있다.
-   앱에 중간 또는 큰 규모의 코드베이스가 있으며 많은 사람들이 작업할 수 있다.
-   애플리케이션의 상태가 언제, 왜, 어떻게 업데이트되었는지 이해하고 시간 경과에 따른 상태 변경을 시각화할 수 있기를 원한다.
-   부작용, 지속성 및 데이터 직렬화를 관리하기 위해 더 강력한 기능이 필요하다.

### 컨텍스트와 Redux의 이해

## React Context란

> 컨텍스트는 모든 수준에서 수동으로 props을 전달하지 않고도 구성 요소 트리를 통해 데이터를 전달하는 방법을 제공한다. 일반적인 React 애플리케이션에서 데이터는 props를 통해 하향식으로 전달되지만 애플리케이션 내의 많은 구성 요소에 필요한 특정 유형의 props에는 번거오울 수 있습니다. 컨텍스트는 트리의 모든 수준을 통해 prop을 명시적을 전달하지 않고도 구성 요소 간의 이와 같은 값을 공유하는 방법을 제공한다.

**context는 리액트 초기버전부터 사용할 수 있었지만 설계 결함이 있었다. 레거시 context의 문제는 구성 요소가 shouldComponentUpdate를 통해 렌더링을 건너뛸 경우 컨텍스트를 통해 전달되는 값에 대한 업데이트가 차단될 수 있다는 것이다.** 그래서 createContext()는 이 문제를 해결하기 위해 설계되었다. 중간에 있는 구성 요소가 렌더링을 건너뛰더라도 하위 구성 요소에서 값에 대한 업데이트를 볼 수 있다.

사용 방법에 대한 설명은 패스하고, 부모 구성 요소가 다시 렌더링하고 컨텍스트 공급자에 대한 새 참조로 전달할 때마다 해당 컨텍스트 value에서 읽는 모든 구성 요소는 강제로 다시 렌더링 하게 된다.

Context는 실제로 어떤 것도 관리하지 않는다. 대신 파이프나 웜홀 같다. `<MyContext.Provider>`를 사용하여 파이프의 상단에 무언가를 넣으면 다른 구성 요소가 요청하는 다른 쪽 끝에서 튀어나올 때까지 파이프를 통해 계속 내려간다. `useContext(MyProvider)`.쪽으로

따라서 Context를 사용하는 주된 목적은 "props 드릴링"방지다. 그리고 개념적으로 이것은 의존성 주입의 한 형태다. 우리는 자식 구성요소가 특정 유형의 값이 필요하다는 것을 알고 있지만 해당 값 자체를 생성하거나 설정하려고 시도하지 않는다. 대신 일부 부모 구성 요소가 런타임에 해당 값을 전달한다고 가정한다. 의존성 주입?

## 리덕스란?

> Redux는 "액션"이라는 이벤트를 사용하여 애플리케이션 상태를 관리하고 업데이트 하기 위한 패턴 및 라이브러리입니다. 상태가 예측 가능한 방식으로만 업데이트 될 수 있도록 하는 규칙과 함께 전체 애플리케이션에서 사용해야 하는 상태에 대한 중앙 집중식 저장소 역할을 합니다. Redux는 애플리케이션의 여러 부분에서 필요한 상태인 "전역" 상태를 관리하는데 도움이 됩니다. Redux에서 제공하는 패턴과 도구를 사용하면 애플리케이션의 상태가 언제, 어디서 왜, 어떻게 업데이트되고 이러한 변경이 발생할 때 애플리케이션 로직이 어떻게 작동하는지 더 쉽게 이해할 수 있다.

역사적으로 리덕스는 원래 React가 나온지 1년 후인 2014년에 Facebook에서 처음 제안한 패턴인 "Flux 아키텍처의 구현으로 만들어졌다." 이에 이어서 Flux 개념에 대한 다양한 접근 방식으로 영감을 받은 수십개의 라이브러리를 만들었다.Redux는 2015년에 나왔고 Flux Wars에서 스일했고 최고의 디자인과 사람들이 해결하려는 문제와 일치했으며 React와 훌륭하게 작동했다.

React-Redux를 사용하면 애플리케이션의 모든 React 구성 요소가 Redux 스토어와 통신할 수 있다. 이것은 내부적으로 React-Redux가 내부적으로 Context를 사용하기 때문에 가능하다. 그러나 React-Redux는 현재 상태 값이 아닌 컨텍스트를 통해 Redux 스토어 인스턴스만 전달한다는 점에 유의해야 한다. 이것은 실제로 위에서 언급한 종속성 주입을 위해 Context를 사용하는 예다. 우리는 Redux에 연결된 React 컴포넌트가 Redux 스토어와 통신해야 한다는 것을 알고 있지만 컴포넌트를 정의할 때 어느 Redux 스토어 인지 모르거나 신경쓰지 않는다. 실제 Redux 저장소는 React-Redux `<Provider>` 구성 요소를 사용하여 런타임에 트리에 주입된다.

이때문에 React-Redux는 특히 React-Redux가 내부적으로 Context를 사용하기 때문에 prop-drilling을 피하기 위해 사용될 수 있다. 새 값을 자신에게 명시적으로 넣는 대신 `<MyContext.Provider>` 해당 데이터를 Redux 저장소에 넣은 다음 어디서나 액세스할 수 있다.

### Redux의 목적과 사용 사례

> Redux에서 제공하는 패턴과 도구를 사용하면 애플리케이션의 상태가 언제, 어디서, 왜, 어떻게 업데이트되고 이러한 변경이 발생할 때 애플리케이션 로직이 어떻게 작동하는지 더 쉽게 이해할 수 있다.

Redux를 사용하려는 추가 이유가 있다. "props 드릴링 방지"는 다른 이유중 하나다. React의 레거시 Context가 문제가 있고, React-Redux가 올바르게 작동했기 때문에 많은 사람들이 prop-drilling을 피하기 위해 초기에 Redux를 선택했다.

Redux를 사용하는 다른 유효한 이유는 다음과 같다.

-   UI 레이어와 완전히 분리된 상태 관리 로직을 작성하고 싶다.
-   서로 다른 UI레이어 간에 상태 관리 로직 공유(예: 앵귤러에서 React로 마이그레이션중인 앱)
-   작업이 발송될 때 Redux 미들웨어의 기능을 사용하여 추가 논리 추가
-   Redux 상태의일부를 유지 가능
-   개발자가 재생할 수 있는 버그 보고서 황성화
-   개발 중 로직 및 UI의 빠른 디버깅

## 컨텍스트가 "상태 관리" 가 아닌 이유

"상태"는 애플리케이션의 동작을 설명하는 모든 데이터입니다. 우리가 원한다면 "서버 상태", "통신 상태", "위치 상태"와 같은 범주로 나눌 수 있지만 핵심은 저장, 읽기, 업데이트 및 사용되는 데이터가 있다는 것이다.

> **상태 관리는 시간이 지남에 따라 상태가 변경되는 방식이다.**

이를 바탕으로 "상태 관리"는 다음과 같은 방법을 갖는 것을 의미한다고 말할 수 있다.

-   초기 값을 저장
-   현재 값 읽기
-   값 업데이트

React useState와 useReducer hooks는 상태 관리의 좋은 예이다. 두 훅을 모두 사용하면 다음을 수행할 수 있다.

-   훅을 호출하여 초기값 저장
-   훅을 호출하여 현재값 읽기
-   setState, dispatch 함수를 호출하여 갑을 업데이트
-   구성 요소가 다시 렌더링되어 값이 업데이트되었음을 알 수 있다.

마찬가지로 Redux와 Mobx는 분명 상태관리다.

-   Redux는 루트 리듀서를 호출하여 초기값을 저장하고, store.getState()로 현재 값을 읽고, store.dispatch(action)로 값을 업데이트하고, store.subscribe(listener)로 리스너에게 저장소가 업데이트되었음을 알린다.
-   Mobx는 스토어 클래스에 필드 값을 할당하여 초기값을 저장하고, 스토어의 필드에 액세스하여 현재 값을 읽을 수 있게 하고, 해당 필드에 할당하여 값을 업데이트한다.

React-Query, SWR, Apollo같은 서버 캐싱 도구는 "상태 관리" 정의에 적합하다고 말할 수 있다. 가져온 데이터를 기반으로 초기값을 저장하고, 후트를 통해 현재 값을 반환하며 업데이트를 허용한다. 또 서버 변경 사항을 다시 렌더링하여 변경사항을 알린다.

React Context는 이러한 기준을 충족하지 않는다. 따라서 컨텍스트는 "상태 관리"도구가 아니다.??? 충족하지 못한다고..?

Context는 자체적으로 어떤 것고 저장하지 않는다. a를 렌더링하는 부모 구성 요소 `<MyContext.Provider>`는 컨텍스트에 전달되는 값을 결정하는 책임이 있으며 해당 값은 일반적으로 React 구성 요소 상태를 기반으로 한다. 실제 "상태 관리"는`useState/useReducer` 훅에서 발생한다.

> 컨텍스트는 상태가 다른 구성 요소와 공유되는 방식이다. 상태 관리와 관련이 없다.

Context가 우리를 위해 하는 모든 일은 prop 드릴링을 건너 뛰는 것이다.

## Context와 Redux 비교

### Context

-   어떤 것도 저장하거나 관리하지 않는다.
-   React 구성 요소에서만 작동
-   무엇이든 될 수 있는 단일 값을 전달한다.
-   해당 단일 값만 읽을 수 있다.
-   props 드릴링을 방지한다.
-   `Provider` React DevTools의 및 구성 요소 모두에 대한 현재 컨텍스트 값을 `Consumer`표시하지만 시간이 지남에 따라 해당 값이 어떻게 변경되었는지에 대한 기록은 표시하지 않는다.
-   컨텍스트 값이 변경되면 소비 구성 요소를 업데이트 하지만 업데이트를 건너뛸 방법은 없다.
-   부작용에 대한 메커니즘을 포함하지 않는다. 순전히 구성 요소를 렌더링하기 위한 것이다.

### React-Redux

-   단일값(객체)을 저장하고 관리한다.
-   React 구성 요소 외부를 포함하여 모든 UI에서 작동
-   해당 단일 값을 읽을 수 있다.
-   props 드릴링 방지
-   reducers, action dispatch를 사용해서 값을 업데이트 가능
-   시간이 지남에 따라 발송된 모든 작업 및 상태 변화의 기록을 보여주는 데브툴스 있음
-   미들웨어를 사용하여 앱 코드가 부작용을 유발하도록 허용
-   구성요소가 스토어 업데이트에 가입하고, 스토어 상태의 특정 부분을 추출하며, 해당 값이 변경된 경우에만 다시 렌더링 할 수 있다.

### 이들의 유일한 겹치는 부분은 props 드릴링을 피하는 것이다.

## Context 그리고 useReducer

useReducer + Context와 Redux + React-Redux의 기능 및 동작에는 많은 차이점이 있다.

-   Context + useReducer는 Context를 통해 현재 상태 값을 전달하는 것에 의존한다.
-   React-Redux는 Context를 통해 현재 Redux 스토어 인스턴스를 전달한다.
-   즉 useReducer, 새 상태 값을 생성할 때 해당 컨텍스트를 구독하는 모든 구성 요소는 데이터의 일부만 신경쓰더라도 강제로 다시 렌더링된다. 이로인해 상태 값의 크기, 해당 데이터를 구독하는 구성 요소의 수 및 재랜더링 빈도에 따라 성능 문제가 발생할 수 있다. 반대로 React-Redux를 사용하면 구성 요소가 스토어 상태의 특정 부분을 구독할 수 있고, 해당 값이 변경될 때만 다시 렌더링 할 수 있다.

또한 몇 가지 다른 중요한 차이점도 있다.

-   Context + useReducer는 React 기능이므로 React 외부에서 사용할 수 없다. 하지만 Redux 스토어는 UI와 독립적이므로 React와 별도로 사용할 수 있습니다.
-   React DevTools를 사용하면 현재 컨텍스트 값을 볼 수 있지만 과거 값이나 시간 경과에 따른 변화는 볼 수 없다. 하지만 Redux DevTools를 사용하면 볼수 있다.
-   useReducer에는 미들웨어가 없다. useEffect와 useReducer를 조합하여 몇 가지 부작용이 있는 일을 할 수 있으며, 미들웨어와 비슷하게 useReducer를 래필하려는 시도는 있었지만 둘다 Redux에 비해 모자라다.

리액트 코어팀 설계자가 한 말

> My personal summary is that new context is ready to be used for low frequency unlikely updates (like locale/theme). It's also good to use it in the same way as old context was used. I.e. for static values and then propagate updates through subscriptions. It's not ready to be used as a replacement for all Flux-like state propagation.

불필요한 리랜더링을 줄이고 범위 문제를 해결하기 위해 서로 다른 상태 청크에 대해 여러 별도의 컨텍스트를 설정하도록 하는 권장하는 게시물이 많이 있는데, 이 구성 요소에는 React.memo(), useMemo의 혼합이 필요하다.물론 이런식으로 작성할 수는 있지만 그 시점에서 우리는 React-Redux를 그냥 다시 만드는 것 뿐이다.

따라서 Context + useReducer, Redux + React-Redux가 언뜻 보기에는 유사하지만 둘은 완전히 동일하지 않으며 Redux를 진정으로 대체할 수 없다.

## 올바른 도구 선택

사용 사례 요약

-   컨텍스트
    -   소품 드릴링 없이 중첩된 구성 요소에 값 전달
-   useReducer
    -   dispatch를 사용하여 다소 복잡한 React 구성요소 상태 관리
-   컨텍스트 + useReducer
    -   리듀서 기능을 사용하고 prop 드릴링 없이 해당 상태 값을 중첩된 구성 요소로 전달하는 다소 복잡한 React 구성 요소 상태 관리
-   리덕스
    -   dispatch를 사용하여 보통에서 매우 복잡한 상태 관리
    -   시간 경과에 따라 상태 추적 관리
    -   UI레이어와 완전히 분리된 상태 관리 로직
    -   작업이 발송될 때 Redux 미들웨어 기능 추가 가능
    -   Redux 상태 일부 유지 가능
    -   개발자가 재생할 수 있는 버그 보고서 활성화
    -   개발 중 로직 및 UI의 더 빠른 디버깅