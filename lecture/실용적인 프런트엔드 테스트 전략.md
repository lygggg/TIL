## 항상 머릿속에 맴도는 질문
- 내가 작성하는 테스트가 정말 나에게 도움을 주고 있는 걸까?
- 프런트엔드 테스트는 대체 무엇을 어떻게 테스트해야 하는 걸까?

## 목차
1. 프런트엔드 테스팅 이해하기
- 테스트 코드를 작성하는 이유
- 프런트엔드 테스트가 어려운 이유: 시각적 요소 검증
3. 시각적 테스트 vs 기능적 테스트
- 시각적 테스트와 기능적 테스트 분리하기
- Storybook을 사용한 시각적 테스트 관리
5. 단위 테스트 vs 통합 테스트
- 단위 테스트, 통합 테스트의 구분과 장단점
- Cypress를 사용한 컴포넌트 단위의 통합 테스트 작성

## 개발자가 왜 테스트를 작성해야 할까?

### Confidence(자신감)
- 내가 작성한 코드가 제대로 작동하는지? 확신, 자신감을 준다.
- 우리는 이것을 전재로 리팩토링, 확장을 수월하게 할 수 있다.

## 프런트엔드의 입력과 출력
### 입력 데이터
- DOM 이벤트: 마우스, 키보드, 터치 등의 입력 이벤트
	- 생성: 브라우저의 이벤트 시뮬레이션 API 사용
- 라우팅/IO: URL 변경, 네트워크/로컬 파일, 로컬 스토리지/쿠키
	- 생성: 브라우저 API 목킹 / E2E 테스트 도구 사용
### 출력 데이터(시각적 요소)
- 코드 관점: HTML, CSS
	- 검증: 생성된 HTML, CSS 코드의 내용을 비교
- 사용자 관점: 브라우저가 렌더링한 화면(픽셀 정보)
	- 검증: 브라우저가 렌더링한 화면을 캡처해서 이미지로 비교

### 시각적 요소의 검증 1: HTML 비교
- 테스트가 나에게 신뢰를 주는가?
	- HTML 구조를 보고 실제 결과물을 예측할 수 있는가?
	- 테스트가 성공하면 항상 의도된 결과가 나온다고 보장할 수 있는가?
	- HTML/CSS를 리팩토링할 떄 테스트가 도움을 주는가?
- 구현 상세 테스트 vs 동작 테스트
	- 구현 상세에 대한 테스트를 지양하고, 동작을 테스트하다, 동작을 테스트하라
	- private 메서드에 대한 테스트를 지양하고, public 인터페이스를 테스트하라.
	- 구현 상세(private): HTML/CSS | 동작(public): 픽셀 정보

### 시각적 요소의 검증 2: 스냅숏 테스트

### 시각적 요소의 검증 3: 이미지 비교
- 캡쳐 이미지의 신뢰성
	- 픽셀 단위 비교: 의미 있는 변경점을 찾기 어려움
	- 운영체제, 브라우저 등의 렌더링 방식 차이
	- 이미지/폰트 로딩 시간, 커서, 애니메이션 등으로 인한 캡처 시점 차이
- 결과 확인 및 이력 관리
	- 커맨드 라인에서 확인 불가능 -> 결과 확인을 위한 UI 필요
	- 브라우저, 뷰포트 크기 등의 케이스별 이미지 파일 생성 / 관리
	- 테스트 실행 돤위별 이미지 파일 히스토리 관리

## 시각적 테스트는 무슨 문제가 있나?
### 테스트 환경 / 실행 속도
- 스크린샷을 생성할 수 있는 환경에서만 테스트 가능
- 테스트 실행 속도가 느림 -> 빠른 피드백을 받을 수 없다. -> 개발 속도 저하
### 테스트의 문서화 기능 / TDD
- 테스트의 의도가 코드에 명확하게 드러나지 않음 -> (문서화 기능)
- TDD 불가능 -> 회귀 테스트 용도로만 사용
### 단일 테스트에 영향을 주는 요소
- 시각적 요소: 레이아웃 변경, 폰트 변경, 색상 변경 등
- 기능적 요소: 사용자 입력 처리, 데이터 연산, 상태 변경
- 테스트가 실패했을 떄 원인을 파악하기가 어려움

## 시각적 테스트 VS 기능적 테스트

|   | 시각적 테스트 | 기능적 테스트 |
|------|---|---|
|용도|회귀 테스트|모든 종류의 테스트|
|TDD|불가능|가능|
|실행 환경|브라우저 외부(조작 가능 환경)|브라우저 내/외부, Node.js|
|테스트 도구|외부 서비스 필요|Jest, Mocha, Jasmine, Puppeteer..|
|결과 확인|이미지 확인을 위한 UI 필요|커맨드 라인에서 확인 가능|
|CI 연동/이력 관리|이미지 확인/관리를 위한 별도 UI 필요|빌트인 기능으로 가능|

우리가 시각적 테스트를 하는 이유는 시각적인 부분은 코드로 검증하기 어렵기 떄문이다.
그렇기 떄문에 어려운 부분만 도려내서 시각적 테스트를 하고 나머지는 하던대로 테스트하는게 좋은 선택이다.

### DOM 탐색 : 잘못된 예
```ts
container.querySelector(".box > .value");
container.querySelector("span.value");
container.querySelector(".text.white");
container.querySelector(".text.white");
container.children[0];
```

### DOM 탐색 : 올바른 예
```ts
container.querySelector(".cound-value");
container.querySelector("[data-testid="count-value]");
```

## Storybook: UI 컴포넌트 개발 환경

### 독립된 컴포넌트 개발 환경
- 전체 애플리케이션에서 컴포넌트를 분리해서 독립된 개발 환경 제공
- 통합된 상태의 환경보다 훨씬 빠른 피드백을 받으며 개발 가능
- 특히 시각적 요소 개발에 특화된 개발 환경

### 컴포넌트의 다양한 상태를 등록/관리
- 특정한 상태의 컴포넌트틀 미리 등록해 놓고 재사용
- 컴포넌트의 다양한 시각적 상태를 빠르게 파악할 수 있음
- 재현하기 어려운 복잡한 상태를 빠르게 재현 후 개발/수정 가능

## 단위 테스트 VS 통합 테스트


## Why Most Unit Testing Is Waste (James O Coplien)

### 테스트는 비용이다
- 테스트 코드는 작성 및 유지보수, 컴퓨팅 시간/자원 등의 비용이 든다
- 불필요한 테스트를 최소화해야 한다
### 단위 테스트는 필수가 아니다
- 복잡한 로직이 없는 코드의 단위 테스트는 `동어반복적`이다
- 단위 테스트는 지엽적인 검증이며, 사업적 가치를 갖지 않는 경우가 많다.
- `시스템 테스트와 중복되는 단위 테스트는 제거하는 것이 좋다`
- 핵심 알고리즘을 갖는 모듈에 대한 단위 테스트는 여전히 중요하다.

## 컴포넌트 단위로 통합 테스트를 하는게 효율적이다
```ts
it("+ 버튼을 클릭하면 1 증가한다", async() => {
	const mockAxios = new MockAdapter(axios);
	mockAxios.onput("/inc").reply(200, {value: 11});

	render(Provider store={store}><Counter/></Provider);

	const btnInc = getByTestId(container, 'btn-inc');
	const value = getByTestId(container, 'value');
	btnInc.click();

	await wait(() => {
	expect(value.textContent).toBe("11");
	});
})
```

## 통합/E2E 테스트 도구


|   | Selenium WebDriver | Cypress |
|------|---|---|
|주 용도|End To End 테스트|통합 테스트|
|TDD|QA / 개발자|(프런트엔드)개발자|
|사용 언어|자바스크립트, 자바, 파이썬..|자바스크립트|
|크로스 브라우징|지원|지원 예정|
|실행 환경|브라우저 외부|브라우저 내부|
|실행 속도|느림|빠름|
|실행 목킹|미지원|지원|

### 브라우저 내부에서 실행
- 브라우저의 디버깅 도구(콘솔, 인스펙터) 사용가능
- 브라우저 익스텐션(리액트/ 리덕스 개발도구) 사용 가능
- UI 개발 환경: 커맨드 라인 환경보다 더 직관적

### 프런트엔드 개발을 위한 기능
- 손쉬운 서버 요청/응답 목킹
- 실행된 모든 명령의 히스토리/스냅숏/데이터 확인 가능
- TDD란 테스트를 먼저 작성하고 그 테스트를 통과시키기 위해 코드를 작성하고 


## 가장 중요한 것은 밸런스!!
### 시각적 테스트 vs 기능적 테스트
- 둘 사이의 구분이 명확하지 않은 경우도 많음
- 프로젝트, 컴포넌트, 기능력 특징에 따라 적절한 방식 선택
- 테스트 가치와 비용을 고려한 균형 있는 선택 필요
### 단위 테스트 vs 통합 테스트
- 단위 테스트와 통합 테스트는 각각의 장단점이 있음
- 컴포넌트 단위의 통합 테스트를 우선적으로 고려
- 모듈 단위 테스트, 애플리케이션 단위의 통합 테스트 등을 보조적으로 사용


## 7줄 요약
1. 내가 작성한 테스트가 신뢰를 주는지 항상 의심하자.
2. 테스트는 비용이다. 불필요한 테스트를 최소화하자.
3. 시각적 테스트와 기능적 테스트를 분리하자.
4. 시각적 테스트를 자동화할 때는 전문 테스트 도구 사용을 고려하자.
5. 모듈 단위 테스트 보다 컴포넌트 단위의 통합 테스트를 먼저 생각하자.
6. 스토리북을 사용하면 시각적 요소를 편리하게 개발/테스트할 수 있다.
7. Cypress를 사용하면 기능적 요소를 편리하게 개발/테스트할 수 있다.