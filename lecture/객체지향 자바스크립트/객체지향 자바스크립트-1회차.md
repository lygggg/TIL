## Value Context VS Identifier Context
```tsx
const a = {
	a:3
	b:5
};
const b = {
	a:3
	b:5
};

console.log(a === b); // Identifier Context
console.log(JSON.stringify(a) === JSON.stringify(b)); //## Value Context
```

### Value Context
1. 끝없는 복사본
2. 상태 변화에 안전?
3. 연산을 기반으로 로직을 전개
### Identifier Context
1. 하나의 원본
2. 상태 변화를 내부에서 책임짐
3. 메세지를 기반으로 로직을 전개

### Polymorphism
```tsx
const Worker = class {
	run(){
		console.log("working")
	}
	print(){
		this.run();
	}
};

const HardWorker = class extends Worker{
	run() {
		console.log("hardWorking")
	}
};

const worker = new HardWorker();
console.log(worker instanceof Worker); // true 자식은 부모를 대체할 수 있다. 대체 가능성
worker.print(); // hardWorking 내적 일관성
```

### 내적 일관성
어떠한 경우에도 태어났을때 원본 클래스를 유지하려는 속성

### 대체 가능성
자식은 부모를 대체할 수 있다.

자바스크립트는 객제치향 언어다. 언어차원에서 Polymorphism(다형성)이 지원이 된다면 객제치향 언어라고 부른다. Polymorphism은 대체 가능성과 내적 일관성을 만족하는 것을 말한다.

```tsx
const EssentialObject = class {
	#home = ""; // hide state
	#screen = null; // hide state
	constructor(name){
		this.#name = name;
		}
	camouflage(){
		this.#screen = (Math.rendom() * 10).toString(16).replace(".", "")
	}
	get name() {
		return this.#screen || this.#name; // encapsulation
	}
}
```

### hide state
객체의 속성이 private인가? 외부로부터 객체 상태를 감춰야한다.
### encapsulation
객체내부가 어떻게 구현되어있는지 자세하게 알려주지 않는 것

## Object essentials(객체지향의 가장 중요한 본질)

### Encapsulation of Functionality
기능의 캡슐화, 메소드를 항상 캡슐화한 상태로 제공해야한다.
### Maintenance of State
객체에 필요한 상태는 내부에서만 관리해야한다.

## Isolation of change
어떠한 변화에 대한 격리 구간을 세워서 변화의 여파가 제한적으로 만들어야 하는것이 궁극적인 목표다.

## SOLID 원칙
1. SRP Single Responsibility 단일 책임의 원칙
2. OCP Open Closed 개방 폐쇄의 원칙
3. LSP Liskov Substitusion 리스코프 치환 법칙(업캐스팅 안전)
4. 인터페이스 분리의 원칙
5. DIP 의존성 역전의 원칙(다운 캐스팅 금지)
	1. Dependency Injection 의존성 주입
	2. DRY Don't Yourself 중복 방지
	3. Hollywood Principle 의존성 부패 방지
	4. Law of demeter 최소 지식