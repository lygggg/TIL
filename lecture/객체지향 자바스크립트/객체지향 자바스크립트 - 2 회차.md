## Model View Controller
![[Pasted image 20221218222856.png]]
- 모델을 컨트롤러가 가져가서 뷰가 소비할수 있는 데이터를 가공해서 뷰에게 전달한다.
- 컨트롤러는 모델도 알고, 뷰도 알고있는 상태다.
- 뷰가 모델을 알고있는게 뭐가 문제일까? 모델은 비즈니스 도메인에 관련이 있는 것이다. 즉 갑자기 변경될수있는 것들이다. 하지만 뷰는 터치환경이나 그림 같은 것에 해당하기 떄문에 뷰와 모델은 변하는게 각자 다르지만 둘은 의존성이 존재한다.
- MVC 패턴의 약점은 view와 model이 많은 의존성을 가지고 있다는 것이다.
- 스프링에서는 model -> controller -> view을 거치고 response를 던지면 끝나는데, 클라이언트에서는 view에 있는 인터렉션이 model로 가기 떄문에 너무 밀접한 양방향 의존성을 가진다.
- 이러한 이유떄문에 서버에서는 mvc를 선호하나 클라이언트에서는 mvc를 선호하지 않는다.

## Model View ViewModel
![[Pasted image 20221218225934.png]]
- mvvm이 성립하려면 바인더가 필요하다. 
- viewModel은 순수한 view다. 진짜 그림을 그리는 view가 아니라 순수한 데이터로서의 view이다. 
- binder가 view와 viewModel의 의존성을 다 가져감으로써 view와 viewModel의 의존성을 없앤다.
- 핵심은 ViewModel이 View를 모른다는 것이다. viewModel은 순수한 모델이기 때문에 view를 알아서는 안된다. 
- 뭐지!! 갑자기 마이크 음질이 나빠졌다...

## Type Check
==  vs === 무조건 일치 연산자를 사용하는게 맞을까? 일치 연산자는 형변환 검사를 하기떄문에 == 보다 속도가 느리다. lint에서도 동등연산자를 사용하지 못하게 막는다. 왜 그럴까? 상황에 따라서 동등 연산자를 사용하는 것도 좋아보이는데 말이다.

## View hook & bind
- bind에 view를 그냥 이식할 수 없다.  왜냐하면 어떤 view에 매칭해야할지 모르기 때문이다. 따라서 view에는 어떤 view 모델과 매칭해야할지에 대한 hook이 필요하다.
```html
<section id="target" data-viewmodel="wrapper">
<h2 data-viewmodel="titel"></h2>
<section data-viewmodel="contents"></section>
</section>
```

![[Pasted image 20221219003252.png]]

## Role Design
- 리액트 방식에서는 모델(state)만 따로 view랑 분리해서 관리할 수 없다. view나 앵귤러는 분리해서 관리가 가능하다.
- 음..

## ViewModel
- 